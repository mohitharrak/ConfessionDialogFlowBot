{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { COLOR_VALUES } from './colorValues';\nexport var MAX_COLOR_SATURATION = 100;\nexport var MAX_COLOR_HUE = 359;\nexport var MAX_COLOR_VALUE = 100;\nexport var MAX_COLOR_RGB = 255;\n/** @deprecated Use MAX_COLOR_RGB (255) or MAX_COLOR_ALPHA (100) */\n\nexport var MAX_COLOR_RGBA = MAX_COLOR_RGB;\nexport var MAX_COLOR_ALPHA = 100;\n/**\r\n * Converts a valid CSS color string to an RGB color.\r\n * Note that hex colors *must* be prefixed with # to be considered valid.\r\n * Alpha in returned color defaults to 100.\r\n */\n\nexport function cssColor(color) {\n  if (!color) {\n    return undefined;\n  }\n\n  return _named(color) || _hex3(color) || _hex6(color) || _rgba(color) || _hsla(color);\n}\n/** Converts RGB components to a hex color string (without # prefix). */\n\nexport function rgb2hex(r, g, b) {\n  return [_rgbToPaddedHex(r), _rgbToPaddedHex(g), _rgbToPaddedHex(b)].join('');\n}\n/** Converts HSV components to a hex color string (without # prefix). */\n\nexport function hsv2hex(h, s, v) {\n  var _a = hsv2rgb(h, s, v),\n      r = _a.r,\n      g = _a.g,\n      b = _a.b;\n\n  return rgb2hex(r, g, b);\n}\n/** Converts RGB components to an HSV color. */\n\nexport function rgb2hsv(r, g, b) {\n  var h = NaN;\n  var s;\n  var v;\n  var max = Math.max(r, g, b);\n  var min = Math.min(r, g, b);\n  var delta = max - min; // hue\n\n  if (delta === 0) {\n    h = 0;\n  } else if (r === max) {\n    h = (g - b) / delta % 6;\n  } else if (g === max) {\n    h = (b - r) / delta + 2;\n  } else if (b === max) {\n    h = (r - g) / delta + 4;\n  }\n\n  h = Math.round(h * 60);\n\n  if (h < 0) {\n    h += 360;\n  } // saturation\n\n\n  s = Math.round((max === 0 ? 0 : delta / max) * 100); // value\n\n  v = Math.round(max / MAX_COLOR_RGB * 100);\n  return {\n    h: h,\n    s: s,\n    v: v\n  };\n}\n/** Converts HSL components to an HSV color. */\n\nexport function hsl2hsv(h, s, l) {\n  s *= (l < 50 ? l : 100 - l) / 100;\n  var v = l + s;\n  return {\n    h: h,\n    s: v === 0 ? 0 : 2 * s / v * 100,\n    v: v\n  };\n}\n/** Converts HSV components to an HSL color. */\n\nexport function hsv2hsl(h, s, v) {\n  s /= MAX_COLOR_SATURATION;\n  v /= MAX_COLOR_VALUE;\n  var l = (2 - s) * v;\n  var sl = s * v;\n  sl /= l <= 1 ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return {\n    h: h,\n    s: sl * 100,\n    l: l * 100\n  };\n}\n/** Converts HSL components to an RGB color. Does not set the alpha value. */\n\nexport function hsl2rgb(h, s, l) {\n  var hsv = hsl2hsv(h, s, l);\n  return hsv2rgb(hsv.h, hsv.s, hsv.v);\n}\n/** Converts HSV components to an RGB color. Does not set the alpha value. */\n\nexport function hsv2rgb(h, s, v) {\n  s = s / 100;\n  v = v / 100;\n  var rgb = [];\n  var c = v * s;\n  var hh = h / 60;\n  var x = c * (1 - Math.abs(hh % 2 - 1));\n  var m = v - c;\n\n  switch (Math.floor(hh)) {\n    case 0:\n      rgb = [c, x, 0];\n      break;\n\n    case 1:\n      rgb = [x, c, 0];\n      break;\n\n    case 2:\n      rgb = [0, c, x];\n      break;\n\n    case 3:\n      rgb = [0, x, c];\n      break;\n\n    case 4:\n      rgb = [x, 0, c];\n      break;\n\n    case 5:\n      rgb = [c, 0, x];\n      break;\n  }\n\n  return {\n    r: Math.round(MAX_COLOR_RGB * (rgb[0] + m)),\n    g: Math.round(MAX_COLOR_RGB * (rgb[1] + m)),\n    b: Math.round(MAX_COLOR_RGB * (rgb[2] + m))\n  };\n}\n/**\r\n * Converts a CSS color string to a color object.\r\n * Note that hex colors *must* be prefixed with # to be considered valid.\r\n *\r\n * `inputColor` will be used unmodified as the `str` property of the returned object.\r\n * Alpha defaults to 100 if not specified in `inputColor`.\r\n * Returns undefined if the color string is invalid/not recognized.\r\n */\n\nexport function getColorFromString(inputColor) {\n  var color = cssColor(inputColor);\n\n  if (!color) {\n    return;\n  }\n\n  return tslib_1.__assign({}, getColorFromRGBA(color), {\n    str: inputColor\n  });\n}\n/** Converts an RGBA color to a color object (alpha defaults to 100). */\n\nexport function getColorFromRGBA(rgba) {\n  var _a = rgba.a,\n      a = _a === void 0 ? MAX_COLOR_ALPHA : _a,\n      b = rgba.b,\n      g = rgba.g,\n      r = rgba.r;\n\n  var _b = rgb2hsv(r, g, b),\n      h = _b.h,\n      s = _b.s,\n      v = _b.v;\n\n  var hex = rgb2hex(r, g, b);\n\n  var str = _rgbaOrHexString(r, g, b, a, hex);\n\n  return {\n    a: a,\n    b: b,\n    g: g,\n    h: h,\n    hex: hex,\n    r: r,\n    s: s,\n    str: str,\n    v: v\n  };\n}\n/**\r\n * Converts an HSV color (and optional alpha value) to a color object.\r\n * If `a` is not given, a default of 100 is used.\r\n * Hex in the returned value will *not* be prefixed with #.\r\n * If `a` is unspecified or 100, the result's `str` property will contain a hex value\r\n * (*not* prefixed with #)\r\n */\n\nexport function getColorFromHSV(hsv, a) {\n  var h = hsv.h,\n      s = hsv.s,\n      v = hsv.v;\n  a = typeof a === 'number' ? a : MAX_COLOR_ALPHA;\n\n  var _a = hsv2rgb(h, s, v),\n      r = _a.r,\n      g = _a.g,\n      b = _a.b;\n\n  var hex = hsv2hex(h, s, v);\n\n  var str = _rgbaOrHexString(r, g, b, a, hex);\n\n  return {\n    a: a,\n    b: b,\n    g: g,\n    h: h,\n    hex: hex,\n    r: r,\n    s: s,\n    str: str,\n    v: v\n  };\n}\n/**\r\n * Converts a color hue to an HTML color string (with # prefix).\r\n * This implementation ignores all components of `color` except hue.\r\n */\n\nexport function getFullColorString(color) {\n  return \"#\" + hsv2hex(color.h, MAX_COLOR_SATURATION, MAX_COLOR_VALUE);\n}\n/**\r\n * Gets a color with the same hue as `color` and other components updated to match the given\r\n * saturation and value.\r\n *\r\n * Does not modify the original `color` and does not supply a default alpha value.\r\n */\n\nexport function updateSV(color, s, v) {\n  var _a = hsv2rgb(color.h, s, v),\n      r = _a.r,\n      g = _a.g,\n      b = _a.b;\n\n  var hex = rgb2hex(r, g, b);\n  return {\n    a: color.a,\n    b: b,\n    g: g,\n    h: color.h,\n    hex: hex,\n    r: r,\n    s: s,\n    str: _rgbaOrHexString(r, g, b, color.a, hex),\n    v: v\n  };\n}\n/**\r\n * Gets a color with the same saturation and value as `color` and the other components updated\r\n * to match the given hue.\r\n *\r\n * Does not modify the original `color` and does not supply a default alpha value.\r\n */\n\nexport function updateH(color, h) {\n  var _a = hsv2rgb(h, color.s, color.v),\n      r = _a.r,\n      g = _a.g,\n      b = _a.b;\n\n  var hex = rgb2hex(r, g, b);\n  return {\n    a: color.a,\n    b: b,\n    g: g,\n    h: h,\n    hex: hex,\n    r: r,\n    s: color.s,\n    str: _rgbaOrHexString(r, g, b, color.a, hex),\n    v: color.v\n  };\n}\n/**\r\n * Gets a color with a single RGBA component updated to a new value.\r\n * Does not modify the original `color`. Alpha defaults to 100 if not set.\r\n */\n\nexport function updateRGB(color, component, value) {\n  return getColorFromRGBA((_a = {\n    r: color.r,\n    g: color.g,\n    b: color.b,\n    a: color.a\n  }, _a[component] = value, _a));\n\n  var _a;\n}\n/**\r\n * Gets a color with the given alpha value and the same other components as `color`.\r\n * Does not modify the original color.\r\n */\n\nexport function updateA(color, a) {\n  return tslib_1.__assign({}, color, {\n    a: a,\n    str: _rgbaOrHexString(color.r, color.g, color.b, a, color.hex)\n  });\n}\n/** Corrects an RGB color to fall within the valid range.  */\n\nexport function correctRGB(color) {\n  return {\n    r: clamp(color.r, MAX_COLOR_RGB),\n    g: clamp(color.g, MAX_COLOR_RGB),\n    b: clamp(color.b, MAX_COLOR_RGB),\n    a: typeof color.a === 'number' ? clamp(color.a, MAX_COLOR_ALPHA) : color.a\n  };\n}\n/** Corrects an HSV color to fall within the valid range. */\n\nexport function correctHSV(color) {\n  return {\n    h: clamp(color.h, MAX_COLOR_HUE),\n    s: clamp(color.s, MAX_COLOR_SATURATION),\n    v: clamp(color.v, MAX_COLOR_VALUE)\n  };\n}\n/** Clamp a value to ensure it falls within a given range. */\n\nexport function clamp(value, max, min) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  return value < min ? min : value > max ? max : value;\n}\n/** Converts an RGB component to a 0-padded hex component of length 2. */\n\nfunction _rgbToPaddedHex(num) {\n  num = clamp(num, MAX_COLOR_RGB);\n  var hex = num.toString(16);\n  return hex.length === 1 ? '0' + hex : hex;\n}\n/**\r\n * If `str` is a valid HTML color name, returns an RGB color (with alpha 100).\r\n * Otherwise returns undefined.\r\n */\n\n\nfunction _named(str) {\n  var c = COLOR_VALUES[str.toLowerCase()];\n\n  if (c) {\n    return {\n      r: c[0],\n      g: c[1],\n      b: c[2],\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}\n/**\r\n * If `str` is in valid `rgb()` or `rgba()` format, returns an RGB color (alpha defaults to 100).\r\n * Otherwise returns undefined.\r\n */\n\n\nfunction _rgba(str) {\n  var match = str.match(/^rgb(a?)\\(([\\d., ]+)\\)$/);\n\n  if (match) {\n    var hasAlpha = !!match[1];\n    var expectedPartCount = hasAlpha ? 4 : 3;\n    var parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      return {\n        r: parts[0],\n        g: parts[1],\n        b: parts[2],\n        a: hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA\n      };\n    }\n  }\n}\n/**\r\n * If `str` is in valid 6-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\r\n * Otherwise returns undefined.\r\n */\n\n\nfunction _hex6(str) {\n  if ('#' === str[0] && 7 === str.length && /^#[\\da-fA-F]{6}$/.test(str)) {\n    return {\n      r: parseInt(str.slice(1, 3), 16),\n      g: parseInt(str.slice(3, 5), 16),\n      b: parseInt(str.slice(5, 7), 16),\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}\n/**\r\n * If `str` is in valid 3-digit hex format *with* # prefix, returns an RGB color (with alpha 100).\r\n * Otherwise returns undefined.\r\n */\n\n\nfunction _hex3(str) {\n  if ('#' === str[0] && 4 === str.length && /^#[\\da-fA-F]{3}$/.test(str)) {\n    return {\n      r: parseInt(str[1] + str[1], 16),\n      g: parseInt(str[2] + str[2], 16),\n      b: parseInt(str[3] + str[3], 16),\n      a: MAX_COLOR_ALPHA\n    };\n  }\n}\n/**\r\n * If `str` is in `hsl()` or `hsla()` format, returns an RGB color (alpha defaults to 100).\r\n * Otherwise returns undefined.\r\n */\n\n\nfunction _hsla(str) {\n  var match = str.match(/^hsl(a?)\\(([\\d., ]+)\\)$/);\n\n  if (match) {\n    var hasAlpha = !!match[1];\n    var expectedPartCount = hasAlpha ? 4 : 3;\n    var parts = match[2].split(/ *, */).map(Number);\n\n    if (parts.length === expectedPartCount) {\n      var rgba = hsl2rgb(parts[0], parts[1], parts[2]);\n      rgba.a = hasAlpha ? parts[3] * 100 : MAX_COLOR_ALPHA;\n      return rgba;\n    }\n  }\n}\n/**\r\n * Get a CSS color string from some color components.\r\n * If `a` is specified and not 100, returns an `rgba()` string.\r\n * Otherwise returns `hex` prefixed with #.\r\n */\n\n\nfunction _rgbaOrHexString(r, g, b, a, hex) {\n  return a === MAX_COLOR_ALPHA || typeof a !== 'number' ? \"#\" + hex : \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a / MAX_COLOR_ALPHA + \")\";\n}","map":null,"metadata":{},"sourceType":"module"}