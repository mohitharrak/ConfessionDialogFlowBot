{"ast":null,"code":"import { getColorFromString } from '../../utilities/color/colors';\nimport { isValidShade, getShade, getBackgroundShade } from '../../utilities/color/shades';\nimport { format } from '../../Utilities';\n\nvar ThemeGenerator =\n/** @class */\nfunction () {\n  function ThemeGenerator() {}\n  /* Sets an IThemeSlotRule to the given color and cascades it to the rest of the theme, updating other IThemeSlotRules in the theme that\r\n   *   inherit from that color.\r\n   * isInverted: whether it's a dark theme or not, which affects the algorithm used to generate shades\r\n   * isCustomization should be true only if it's a user action, and indicates overwriting the slot's inheritance (if any)\r\n   * overwriteCustomColor: a slot could have a generated color based on its inheritance rules (isCustomized is false), or a custom color\r\n                            based on user input (isCustomized is true), this bool tells us whether to override existing customized colors */\n\n\n  ThemeGenerator.setSlot = function (rule, color, isInverted, isCustomization, overwriteCustomColor) {\n    if (isInverted === void 0) {\n      isInverted = false;\n    }\n\n    if (isCustomization === void 0) {\n      isCustomization = false;\n    }\n\n    if (overwriteCustomColor === void 0) {\n      overwriteCustomColor = true;\n    }\n\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor) {\n      var colorAsIColor = void 0;\n\n      if (typeof color === 'string') {\n        colorAsIColor = getColorFromString(color); // the ! is a lie here but we'll verify it in the next line\n\n        if (!colorAsIColor) {\n          throw 'color is invalid in setSlot(): ' + color;\n        }\n      } else {\n        colorAsIColor = color;\n      }\n\n      ThemeGenerator._setSlot(rule, colorAsIColor, isInverted, isCustomization, overwriteCustomColor);\n    } else if (rule.color) {\n      ThemeGenerator._setSlot(rule, rule.color, isInverted, isCustomization, overwriteCustomColor);\n    }\n  };\n  /* Sets the color of each slot based on its rule. Slots that don't inherit must have a color already.\r\n   * If this completes without error, then the theme is ready to use. (All slots will have a color.)\r\n   * setSlot() can be called before this, but this must be called before getThemeAs*().\r\n   * Does not override colors of rules where isCustomized is true (i.e. doesn't override existing customizations).\r\n   */\n\n\n  ThemeGenerator.insureSlots = function (slotRules, isInverted) {\n    // Get all the \"root\" rules, the ones which don't inherit. Then \"set\" them to trigger updating dependent slots.\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n\n        if (!rule.inherits && !rule.value) {\n          if (!rule.color) {\n            throw 'A color slot rule that does not inherit must provide its own color.';\n          }\n\n          ThemeGenerator._setSlot(rule, rule.color, isInverted, false, false);\n        }\n      }\n    }\n  };\n  /* Gets the JSON-formatted blob that describes the theme, usable with the REST request endpoints\r\n   * { [theme slot name as string] : [color as string],\r\n   *  \"tokenName\": \"#f00f00\",\r\n   *  \"tokenName2\": \"#ba2ba2\",\r\n   *   ... }\r\n   */\n\n\n  ThemeGenerator.getThemeAsJson = function (slotRules) {\n    var theme = {};\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n        theme[rule.name] = rule.color ? rule.color.str : rule.value || '';\n      }\n    }\n\n    return theme;\n  };\n  /*\r\n   * Gets code-formatted load theme blob that can be copy and pasted.\r\n   */\n\n\n  ThemeGenerator.getThemeAsCode = function (slotRules) {\n    var attributeTemplate = \"    {0}: '{1}',\\n\";\n    var output = '';\n    output += 'loadTheme({\\n  palette: {\\n';\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n        var camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        var outputColor = rule.color ? '#' + rule.color.hex : rule.value || '';\n        output += format(attributeTemplate, camelCasedName, outputColor);\n      }\n    }\n\n    output += '  }\\n});';\n    return output;\n  };\n  /* Gets the theme as a list of SASS variables that can be used in code\r\n   * $tokenName: \"[theme:tokenName, default:#f00f00]\";\r\n   * $tokenName2: \"[theme:tokenName2, default:#ba2ba2]\";\r\n   * ...\r\n   */\n\n\n  ThemeGenerator.getThemeAsSass = function (slotRules) {\n    var sassVarTemplate = '${0}Color: \"[theme: {1}, default: {2}]\";\\n';\n    var output = '';\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n        var camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        output += format(sassVarTemplate, camelCasedName, camelCasedName, rule.color ? rule.color.str : rule.value || '');\n      }\n    }\n\n    return output;\n  };\n  /* Gets the theme formatted for PowerShell scripts\r\n   * @{\r\n   * \"tokenName\" = \"#f00f00\";\r\n   * \"tokenName2\" = \"#ba2ba2\";\r\n   * ...\r\n   * }\r\n   */\n\n\n  ThemeGenerator.getThemeForPowerShell = function (slotRules) {\n    var psVarTemplate = '\"{0}\" = \"{1}\";\\n';\n    var output = '';\n\n    for (var ruleName in slotRules) {\n      if (slotRules.hasOwnProperty(ruleName)) {\n        var rule = slotRules[ruleName];\n\n        if (rule.value) {\n          // skip this one, it's not a color\n          continue;\n        }\n\n        var camelCasedName = rule.name.charAt(0).toLowerCase() + rule.name.slice(1);\n        var outputColor = rule.color ? '#' + rule.color.hex : rule.value || ''; // powershell endpoint uses the RGBA format\n\n        if (rule.color && rule.color.a && rule.color.a !== 100) {\n          outputColor += String(rule.color.a.toString(16));\n        }\n\n        output += format(psVarTemplate, camelCasedName, outputColor);\n      }\n    }\n\n    return '@{\\n' + output + '}';\n  };\n  /* Sets the given slot's color to the appropriate color, shading it if necessary.\r\n     Then, iterates through all other rules (that are this rule's dependents) to update them accordingly.\r\n     isCustomization=true means it's a user provided color, set it to that raw color\r\n     isCustomization=false means the rule it's inheriting from changed, so updated using asShade */\n\n\n  ThemeGenerator._setSlot = function (rule, color, isInverted, isCustomization, overwriteCustomColor) {\n    if (overwriteCustomColor === void 0) {\n      overwriteCustomColor = true;\n    }\n\n    if (!rule.color && rule.value) {\n      // not a color rule\n      return;\n    }\n\n    if (overwriteCustomColor || !rule.color || !rule.isCustomized || !rule.inherits) {\n      // set the rule's color under these conditions\n      if ((overwriteCustomColor || !rule.isCustomized) && !isCustomization && rule.inherits && isValidShade(rule.asShade)) {\n        // it's inheriting by shade\n        if (rule.isBackgroundShade) {\n          rule.color = getBackgroundShade(color, rule.asShade, isInverted);\n        } else {\n          rule.color = getShade(color, rule.asShade, isInverted);\n        }\n\n        rule.isCustomized = false;\n      } else {\n        rule.color = color;\n        rule.isCustomized = true;\n      } // then update dependent colors\n\n\n      for (var _i = 0, _a = rule.dependentRules; _i < _a.length; _i++) {\n        var ruleToUpdate = _a[_i];\n\n        ThemeGenerator._setSlot(ruleToUpdate, rule.color, isInverted, false, overwriteCustomColor);\n      }\n    }\n  };\n\n  return ThemeGenerator;\n}();\n\nexport { ThemeGenerator };","map":null,"metadata":{},"sourceType":"module"}