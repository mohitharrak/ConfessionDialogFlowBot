{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseComponent, KeyCodes, css, getId, getRTL, getRTLSafeKeyCode } from '../../Utilities';\nimport { classNamesFunction, getNativeProps, divProperties } from '../../Utilities';\nimport { Label } from '../../Label';\n/**\r\n * @deprecated Unused.\r\n */\n\nexport var ValuePosition;\n\n(function (ValuePosition) {\n  ValuePosition[ValuePosition[\"Previous\"] = 0] = \"Previous\";\n  ValuePosition[ValuePosition[\"Next\"] = 1] = \"Next\";\n})(ValuePosition || (ValuePosition = {}));\n\nvar getClassNames = classNamesFunction();\n\nvar SliderBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SliderBase, _super);\n\n  function SliderBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._sliderLine = React.createRef();\n    _this._thumb = React.createRef();\n\n    _this._getAriaValueText = function (value) {\n      if (_this.props.ariaValueText && value !== undefined) {\n        return _this.props.ariaValueText(value);\n      }\n    };\n\n    _this._onMouseDownOrTouchStart = function (event) {\n      if (event.type === 'mousedown') {\n        _this._events.on(window, 'mousemove', _this._onMouseMoveOrTouchMove, true);\n\n        _this._events.on(window, 'mouseup', _this._onMouseUpOrTouchEnd, true);\n      } else if (event.type === 'touchstart') {\n        _this._events.on(window, 'touchmove', _this._onMouseMoveOrTouchMove, true);\n\n        _this._events.on(window, 'touchend', _this._onMouseUpOrTouchEnd, true);\n      }\n\n      _this._onMouseMoveOrTouchMove(event, true);\n    };\n\n    _this._onMouseMoveOrTouchMove = function (event, suppressEventCancelation) {\n      if (!_this._sliderLine.current) {\n        return;\n      }\n\n      var _a = _this.props,\n          max = _a.max,\n          min = _a.min,\n          step = _a.step;\n      var steps = (max - min) / step;\n\n      var sliderPositionRect = _this._sliderLine.current.getBoundingClientRect();\n\n      var sliderLength = !_this.props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n      var stepLength = sliderLength / steps;\n      var currentSteps;\n      var distance;\n\n      if (!_this.props.vertical) {\n        var left = _this._getPosition(event, _this.props.vertical);\n\n        distance = getRTL() ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n        currentSteps = distance / stepLength;\n      } else {\n        var bottom = _this._getPosition(event, _this.props.vertical);\n\n        distance = sliderPositionRect.bottom - bottom;\n        currentSteps = distance / stepLength;\n      }\n\n      var currentValue;\n      var renderedValue; // The value shouldn't be bigger than max or be smaller than min.\n\n      if (currentSteps > Math.floor(steps)) {\n        renderedValue = currentValue = max;\n      } else if (currentSteps < 0) {\n        renderedValue = currentValue = min;\n      } else {\n        renderedValue = min + step * currentSteps;\n        currentValue = min + step * Math.round(currentSteps);\n      }\n\n      _this._updateValue(currentValue, renderedValue);\n\n      if (!suppressEventCancelation) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    };\n\n    _this._onMouseUpOrTouchEnd = function (event) {\n      // Synchronize the renderedValue to the actual value.\n      _this.setState({\n        renderedValue: _this.state.value\n      });\n\n      if (_this.props.onChanged) {\n        _this.props.onChanged(event, _this.state.value);\n      }\n\n      _this._events.off();\n    };\n\n    _this._onKeyDown = function (event) {\n      var value = _this.state.value;\n      var _a = _this.props,\n          max = _a.max,\n          min = _a.min,\n          step = _a.step;\n      var diff = 0;\n\n      switch (event.which) {\n        case getRTLSafeKeyCode(KeyCodes.left):\n        case KeyCodes.down:\n          diff = -step;\n          break;\n\n        case getRTLSafeKeyCode(KeyCodes.right):\n        case KeyCodes.up:\n          diff = step;\n          break;\n\n        case KeyCodes.home:\n          value = min;\n          break;\n\n        case KeyCodes.end:\n          value = max;\n          break;\n\n        default:\n          return;\n      }\n\n      var newValue = Math.min(max, Math.max(min, value + diff));\n\n      _this._updateValue(newValue, newValue);\n\n      event.preventDefault();\n      event.stopPropagation();\n    };\n\n    _this._warnMutuallyExclusive({\n      value: 'defaultValue'\n    });\n\n    _this._id = getId('Slider');\n    var value = props.value !== undefined ? props.value : props.defaultValue !== undefined ? props.defaultValue : props.min;\n    _this.state = {\n      value: value,\n      renderedValue: value\n    };\n    return _this;\n  }\n  /**\r\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\r\n   */\n\n\n  SliderBase.prototype.componentWillReceiveProps = function (newProps) {\n    if (newProps.value !== undefined) {\n      var value = Math.max(newProps.min, Math.min(newProps.max, newProps.value));\n      this.setState({\n        value: value,\n        renderedValue: value\n      });\n    }\n  };\n\n  SliderBase.prototype.render = function () {\n    var _a = this.props,\n        ariaLabel = _a.ariaLabel,\n        className = _a.className,\n        disabled = _a.disabled,\n        label = _a.label,\n        max = _a.max,\n        min = _a.min,\n        showValue = _a.showValue,\n        buttonProps = _a.buttonProps,\n        vertical = _a.vertical,\n        valueFormat = _a.valueFormat,\n        styles = _a.styles,\n        theme = _a.theme;\n    var _b = this.state,\n        value = _b.value,\n        renderedValue = _b.renderedValue;\n    var thumbOffsetPercent = min === max ? 0 : (renderedValue - min) / (max - min) * 100;\n    var lengthString = vertical ? 'height' : 'width';\n    var onMouseDownProp = disabled ? {} : {\n      onMouseDown: this._onMouseDownOrTouchStart\n    };\n    var onTouchStartProp = disabled ? {} : {\n      onTouchStart: this._onMouseDownOrTouchStart\n    };\n    var onKeyDownProp = disabled ? {} : {\n      onKeyDown: this._onKeyDown\n    };\n    var classNames = getClassNames(styles, {\n      className: className,\n      disabled: disabled,\n      vertical: vertical,\n      showTransitions: renderedValue === value,\n      showValue: showValue,\n      theme: theme\n    });\n    var divButtonProps = buttonProps ? getNativeProps(buttonProps, divProperties) : undefined;\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, label && React.createElement(Label, tslib_1.__assign({\n      className: classNames.titleLabel\n    }, ariaLabel ? {} : {\n      htmlFor: this._id\n    }), label), React.createElement(\"div\", {\n      className: classNames.container\n    }, React.createElement(\"div\", tslib_1.__assign({\n      \"aria-valuenow\": value,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuetext\": this._getAriaValueText(value),\n      \"aria-label\": ariaLabel || label,\n      \"aria-disabled\": disabled\n    }, onMouseDownProp, onTouchStartProp, onKeyDownProp, divButtonProps, {\n      className: css(classNames.slideBox, buttonProps.className),\n      id: this._id,\n      role: \"slider\",\n      tabIndex: disabled ? undefined : 0,\n      \"data-is-focusable\": !disabled\n    }), React.createElement(\"div\", {\n      ref: this._sliderLine,\n      className: classNames.line\n    }, React.createElement(\"span\", {\n      ref: this._thumb,\n      className: classNames.thumb,\n      style: this._getThumbStyle(vertical, thumbOffsetPercent)\n    }), React.createElement(\"span\", {\n      className: css(classNames.lineContainer, classNames.activeSection),\n      style: (_c = {}, _c[lengthString] = thumbOffsetPercent + '%', _c)\n    }), React.createElement(\"span\", {\n      className: css(classNames.lineContainer, classNames.inactiveSection),\n      style: (_d = {}, _d[lengthString] = 100 - thumbOffsetPercent + '%', _d)\n    }))), showValue && React.createElement(Label, {\n      className: classNames.valueLabel\n    }, valueFormat ? valueFormat(value) : value)));\n\n    var _c, _d;\n  };\n\n  SliderBase.prototype.focus = function () {\n    if (this._thumb.current) {\n      this._thumb.current.focus();\n    }\n  };\n\n  Object.defineProperty(SliderBase.prototype, \"value\", {\n    get: function get() {\n      return this.state.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SliderBase.prototype._getThumbStyle = function (vertical, thumbOffsetPercent) {\n    var direction = vertical ? 'bottom' : getRTL() ? 'right' : 'left';\n    return _a = {}, _a[direction] = thumbOffsetPercent + '%', _a;\n\n    var _a;\n  };\n\n  SliderBase.prototype._getPosition = function (event, vertical) {\n    var currentPosition;\n\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !vertical ? event.clientX : event.clientY;\n        break;\n\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !vertical ? event.touches[0].clientX : event.touches[0].clientY;\n        break;\n    }\n\n    return currentPosition;\n  };\n\n  SliderBase.prototype._updateValue = function (value, renderedValue) {\n    var _this = this;\n\n    var step = this.props.step;\n    var numDec = 0;\n\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    } // Make sure value has correct number of decimal places based on number of decimals in step\n\n\n    var roundedValue = parseFloat(value.toFixed(numDec));\n    var valueChanged = roundedValue !== this.state.value;\n    this.setState({\n      value: roundedValue,\n      renderedValue: renderedValue\n    }, function () {\n      if (valueChanged && _this.props.onChange) {\n        _this.props.onChange(_this.state.value);\n      }\n    });\n  };\n\n  SliderBase.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 10,\n    showValue: true,\n    disabled: false,\n    vertical: false,\n    buttonProps: {}\n  };\n  return SliderBase;\n}(BaseComponent);\n\nexport { SliderBase };","map":null,"metadata":{},"sourceType":"module"}