{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { getLayerStyles } from './KeytipLayer.styles';\nimport { Keytip } from '../../Keytip';\nimport { Layer } from '../../Layer';\nimport { BaseComponent, classNamesFunction, getDocument, arraysEqual, warn, isMac } from '../../Utilities';\nimport { KeytipManager } from '../../utilities/keytips/KeytipManager';\nimport { KeytipTree } from './KeytipTree';\nimport { ktpTargetFromId, ktpTargetFromSequences, sequencesToID, mergeOverflows } from '../../utilities/keytips/KeytipUtils';\nimport { transitionKeysContain, KeytipTransitionModifier } from '../../utilities/keytips/IKeytipTransitionKey';\nimport { KeytipEvents, KTP_LAYER_ID, KTP_ARIA_SEPARATOR } from '../../utilities/keytips/KeytipConstants'; // Default sequence is Alt-Windows (Alt-Meta) in Windows, Option-Control (Alt-Control) in Mac\n\nvar defaultStartSequence = {\n  key: isMac() ? 'Control' : 'Meta',\n  modifierKeys: [KeytipTransitionModifier.alt]\n}; // Default exit sequence is the same as the start sequence\n\nvar defaultExitSequence = defaultStartSequence; // Default return sequence is Escape\n\nvar defaultReturnSequence = {\n  key: 'Escape'\n};\nvar getClassNames = classNamesFunction();\n/**\r\n * A layer that holds all keytip items\r\n */\n\nvar KeytipLayerBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(KeytipLayerBase, _super); // tslint:disable-next-line:no-any\n\n\n  function KeytipLayerBase(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this._keytipManager = KeytipManager.getInstance();\n    _this._delayedKeytipQueue = [];\n    _this._keyHandled = false;\n\n    _this._onDismiss = function (ev) {\n      // if we are in keytip mode, then exit keytip mode\n      if (_this.state.inKeytipMode) {\n        _this._exitKeytipMode(ev);\n      }\n    };\n\n    _this._onKeyDown = function (ev) {\n      _this._keyHandled = false; // using key since which has been deprecated and key is now widely suporrted.\n      // See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which\n\n      var key = ev.key;\n\n      switch (key) {\n        case 'Alt':\n          // ALT puts focus in the browser bar, so it should not be used as a key for keytips.\n          // It can be used as a modifier\n          break;\n\n        case 'Tab':\n        case 'Enter':\n        case 'Spacebar':\n        case ' ':\n        case 'ArrowUp':\n        case 'Up':\n        case 'ArrowDown':\n        case 'Down':\n        case 'ArrowLeft':\n        case 'Left':\n        case 'ArrowRight':\n        case 'Right':\n          if (_this.state.inKeytipMode) {\n            _this._keyHandled = true;\n\n            _this._exitKeytipMode(ev);\n          }\n\n          break;\n\n        default:\n          // Special cases for browser-specific keys that are not at standard\n          // (according to http://www.w3.org/TR/uievents-key/#keys-navigation)\n          if (key === 'Esc') {\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5290772/\n            key = 'Escape';\n          } else if (key === 'OS' || key === 'Win') {\n            // Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1232918\n            // Edge: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n            // and https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/16424492/\n            key = 'Meta';\n          }\n\n          var transitionKey = {\n            key: key\n          };\n          transitionKey.modifierKeys = _this._getModifierKey(key, ev);\n\n          _this.processTransitionInput(transitionKey, ev);\n\n          break;\n      }\n    };\n\n    _this._onKeyPress = function (ev) {\n      if (_this.state.inKeytipMode && !_this._keyHandled) {\n        // Call processInput\n        _this.processInput(ev.key.toLocaleLowerCase(), ev);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    _this._onKeytipAdded = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.addNode(keytipProps, uniqueID);\n\n      _this._setKeytips(); // Add the keytip to the queue to show later\n\n\n      if (_this._keytipTree.isCurrentKeytipParent(keytipProps)) {\n        _this._addKeytipToQueue(sequencesToID(keytipProps.keySequences));\n      }\n\n      if (_this._newCurrentKeytipSequences && arraysEqual(keytipProps.keySequences, _this._newCurrentKeytipSequences)) {\n        _this._triggerKeytipImmediately(keytipProps);\n      }\n\n      if (_this._isCurrentKeytipAnAlias(keytipProps)) {\n        var keytipSequence = keytipProps.keySequences;\n\n        if (keytipProps.overflowSetSequence) {\n          keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n        }\n\n        _this._keytipTree.currentKeytip = _this._keytipTree.getNode(sequencesToID(keytipSequence));\n      }\n    };\n\n    _this._onKeytipUpdated = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.updateNode(keytipProps, uniqueID);\n\n      _this._setKeytips();\n    };\n\n    _this._onKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID; // Remove keytip from the delayed queue\n\n      _this._removeKeytipFromQueue(sequencesToID(keytipProps.keySequences)); // Remove the node from the Tree\n\n\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n\n      _this._setKeytips();\n    };\n\n    _this._onPersistedKeytipAdded = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.addNode(keytipProps, uniqueID, true);\n    };\n\n    _this._onPersistedKeytipRemoved = function (eventArgs) {\n      var keytipProps = eventArgs.keytip;\n      var uniqueID = eventArgs.uniqueID;\n\n      _this._keytipTree.removeNode(keytipProps, uniqueID);\n    };\n\n    _this._onPersistedKeytipExecute = function (eventArgs) {\n      _this._persistedKeytipExecute(eventArgs.overflowButtonSequences, eventArgs.keytipSequences);\n    };\n    /**\r\n     * Sets if we are in keytip mode.\r\n     * Note, this sets both the state for the layer as well as\r\n     * the value that the manager will expose externally.\r\n     * @param inKeytipMode - Boolean so set whether we are in keytip mode or not\r\n     */\n\n\n    _this._setInKeytipMode = function (inKeytipMode) {\n      _this.setState({\n        inKeytipMode: inKeytipMode\n      });\n\n      _this._keytipManager.inKeytipMode = inKeytipMode;\n    };\n    /**\r\n     * Emits a warning if duplicate keytips are found for the children of the current keytip\r\n     */\n\n\n    _this._warnIfDuplicateKeytips = function () {\n      var duplicateKeytips = _this._getDuplicateIds(_this._keytipTree.getChildren());\n\n      if (duplicateKeytips.length) {\n        warn('Duplicate keytips found for ' + duplicateKeytips.join(', '));\n      }\n    };\n    /**\r\n     * Returns duplicates among keytip IDs\r\n     * If the returned array is empty, no duplicates were found\r\n     *\r\n     * @param keytipIds - Array of keytip IDs to find duplicates for\r\n     * @returns - Array of duplicates that were found. If multiple duplicates were found it will only be added once to this array\r\n     */\n\n\n    _this._getDuplicateIds = function (keytipIds) {\n      var seenIds = {};\n      return keytipIds.filter(function (keytipId) {\n        seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1; // Only add the first duplicate keytip seen\n\n        return seenIds[keytipId] === 2;\n      });\n    };\n\n    var managerKeytips = _this._keytipManager.getKeytips().slice();\n\n    _this.state = {\n      inKeytipMode: false,\n      // Get the initial set of keytips\n      keytips: managerKeytips,\n      visibleKeytips: _this._getVisibleKeytips(managerKeytips)\n    };\n    _this._keytipTree = new KeytipTree(); // Add regular and persisted keytips to the tree\n\n    for (var _i = 0, _a = _this._keytipManager.keytips.concat(_this._keytipManager.persistedKeytips); _i < _a.length; _i++) {\n      var uniqueKeytip = _a[_i];\n\n      _this._keytipTree.addNode(uniqueKeytip.keytip, uniqueKeytip.uniqueID);\n    }\n\n    _this._currentSequence = ''; // Add keytip listeners\n\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_ADDED, _this._onKeytipAdded);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_UPDATED, _this._onKeytipUpdated);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.KEYTIP_REMOVED, _this._onKeytipRemoved);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, _this._onPersistedKeytipAdded);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, _this._onPersistedKeytipRemoved);\n\n    _this._events.on(_this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, _this._onPersistedKeytipExecute);\n\n    return _this;\n  }\n\n  KeytipLayerBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        content = _a.content,\n        styles = _a.styles;\n    var _b = this.state,\n        keytips = _b.keytips,\n        visibleKeytips = _b.visibleKeytips;\n    this._classNames = getClassNames(styles, {});\n    return React.createElement(Layer, {\n      styles: getLayerStyles\n    }, React.createElement(\"span\", {\n      id: KTP_LAYER_ID,\n      className: this._classNames.innerContent\n    }, \"\" + content + KTP_ARIA_SEPARATOR), keytips && keytips.map(function (keytipProps, index) {\n      return React.createElement(\"span\", {\n        key: index,\n        id: sequencesToID(keytipProps.keySequences),\n        className: _this._classNames.innerContent\n      }, keytipProps.keySequences.join(KTP_ARIA_SEPARATOR));\n    }), visibleKeytips && visibleKeytips.map(function (visibleKeytipProps) {\n      return React.createElement(Keytip, tslib_1.__assign({\n        key: sequencesToID(visibleKeytipProps.keySequences)\n      }, visibleKeytipProps));\n    }));\n  };\n\n  KeytipLayerBase.prototype.componentDidMount = function () {\n    // Add window listeners\n    this._events.on(window, 'mouseup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'pointerup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'resize', this._onDismiss);\n\n    this._events.on(window, 'keydown', this._onKeyDown, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'keypress', this._onKeyPress, true\n    /* useCapture */\n    );\n\n    this._events.on(window, 'scroll', this._onDismiss, true\n    /* useCapture */\n    ); // Add keytip listeners\n\n\n    this._events.on(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n\n    this._events.on(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  };\n\n  KeytipLayerBase.prototype.componentWillUnmount = function () {\n    // Remove window listeners\n    this._events.off(window, 'mouseup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'pointerup', this._onDismiss, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'resize', this._onDismiss);\n\n    this._events.off(window, 'keydown', this._onKeyDown, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'keypress', this._onKeyPress, true\n    /* useCapture */\n    );\n\n    this._events.off(window, 'scroll', this._onDismiss, true\n    /* useCapture */\n    ); // Remove keytip listeners\n\n\n    this._events.off(this._keytipManager, KeytipEvents.KEYTIP_ADDED, this._onKeytipAdded);\n\n    this._events.off(this._keytipManager, KeytipEvents.KEYTIP_UPDATED, this._onKeytipUpdated);\n\n    this._events.off(this._keytipManager, KeytipEvents.KEYTIP_REMOVED, this._onKeytipRemoved);\n\n    this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_ADDED, this._onPersistedKeytipAdded);\n\n    this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_REMOVED, this._onPersistedKeytipRemoved);\n\n    this._events.off(this._keytipManager, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, this._onPersistedKeytipExecute);\n\n    this._events.off(this._keytipManager, KeytipEvents.ENTER_KEYTIP_MODE, this._enterKeytipMode);\n\n    this._events.off(this._keytipManager, KeytipEvents.EXIT_KEYTIP_MODE, this._exitKeytipMode);\n  }; // The below public functions are only public for testing purposes\n  // They are not intended to be used in app code by using a KeytipLayer reference\n\n\n  KeytipLayerBase.prototype.getCurrentSequence = function () {\n    return this._currentSequence;\n  };\n\n  KeytipLayerBase.prototype.getKeytipTree = function () {\n    return this._keytipTree;\n  };\n  /**\r\n   * Processes an IKeytipTransitionKey entered by the user\r\n   *\r\n   * @param transitionKey - IKeytipTransitionKey received by the layer to process\r\n   */\n\n\n  KeytipLayerBase.prototype.processTransitionInput = function (transitionKey, ev) {\n    var currKtp = this._keytipTree.currentKeytip;\n\n    if (transitionKeysContain(this.props.keytipExitSequences, transitionKey) && currKtp) {\n      // If key sequence is in 'exit sequences', exit keytip mode\n      this._keyHandled = true;\n\n      this._exitKeytipMode(ev);\n    } else if (transitionKeysContain(this.props.keytipReturnSequences, transitionKey)) {\n      // If key sequence is in return sequences, move currentKeytip to parent (or if currentKeytip is the root, exit)\n      if (currKtp) {\n        this._keyHandled = true;\n\n        if (currKtp.id === this._keytipTree.root.id) {\n          // We are at the root, exit keytip mode\n          this._exitKeytipMode(ev);\n        } else {\n          // If this keytip has a onReturn prop, we execute the func.\n          if (currKtp.onReturn) {\n            currKtp.onReturn(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp));\n          } // Reset currentSequence\n\n\n          this._currentSequence = ''; // Return pointer to its parent\n\n          this._keytipTree.currentKeytip = this._keytipTree.getNode(currKtp.parent); // Show children keytips of the new currentKeytip\n\n          this.showKeytips(this._keytipTree.getChildren());\n\n          this._warnIfDuplicateKeytips();\n        }\n      }\n    } else if (transitionKeysContain(this.props.keytipStartSequences, transitionKey) && !currKtp) {\n      // If key sequence is in 'entry sequences' and currentKeytip is null, we enter keytip mode\n      this._keyHandled = true;\n\n      this._enterKeytipMode();\n\n      this._warnIfDuplicateKeytips();\n    }\n  };\n  /**\r\n   * Processes inputs from the document listener and traverse the keytip tree\r\n   *\r\n   * @param key - Key pressed by the user\r\n   */\n\n\n  KeytipLayerBase.prototype.processInput = function (key, ev) {\n    // Concat the input key with the current sequence\n    var currSequence = this._currentSequence + key;\n    var currKtp = this._keytipTree.currentKeytip; // currentKeytip must be defined, otherwise we haven't entered keytip mode yet\n\n    if (currKtp) {\n      var node = this._keytipTree.getExactMatchedNode(currSequence, currKtp);\n\n      if (node) {\n        this._keytipTree.currentKeytip = currKtp = node;\n\n        var currKtpChildren = this._keytipTree.getChildren(); // Execute this node's onExecute if defined\n\n\n        if (currKtp.onExecute) {\n          currKtp.onExecute(this._getKtpExecuteTarget(currKtp), this._getKtpTarget(currKtp)); // Reset currKtp, this might have changed from the onExecute\n\n          currKtp = this._keytipTree.currentKeytip;\n        } // To exit keytipMode after executing the keytip it must not have a menu or have dynamic children\n\n\n        if (currKtpChildren.length === 0 && !(currKtp.hasDynamicChildren || currKtp.hasMenu)) {\n          this._exitKeytipMode(ev);\n        } else {\n          // Show all children keytips\n          this.showKeytips(currKtpChildren);\n\n          this._warnIfDuplicateKeytips();\n        } // Clear currentSequence\n\n\n        this._currentSequence = '';\n        return;\n      }\n\n      var partialNodes = this._keytipTree.getPartiallyMatchedNodes(currSequence, currKtp);\n\n      if (partialNodes.length > 0) {\n        // We found nodes that partially match the sequence, so we show only those\n        // Omit showing persisted nodes here\n        var ids = partialNodes.filter(function (partialNode) {\n          return !partialNode.persisted;\n        }).map(function (partialNode) {\n          return partialNode.id;\n        });\n        this.showKeytips(ids); // Save currentSequence\n\n        this._currentSequence = currSequence;\n      }\n    }\n  };\n  /**\r\n   * Show the given keytips and hide all others\r\n   *\r\n   * @param ids - Keytip IDs to show\r\n   */\n\n\n  KeytipLayerBase.prototype.showKeytips = function (ids) {\n    // Update the visible prop in the manager\n    for (var _i = 0, _a = this._keytipManager.getKeytips(); _i < _a.length; _i++) {\n      var keytip = _a[_i];\n      var keytipId = sequencesToID(keytip.keySequences);\n\n      if (ids.indexOf(keytipId) >= 0) {\n        keytip.visible = true;\n      } else if (keytip.overflowSetSequence && ids.indexOf(sequencesToID(mergeOverflows(keytip.keySequences, keytip.overflowSetSequence))) >= 0) {\n        // Check if the ID with the overflow is the keytip we're looking for\n        keytip.visible = true;\n      } else {\n        keytip.visible = false;\n      }\n    } // Apply the manager changes to the Layer state\n\n\n    this._setKeytips();\n  };\n  /**\r\n   * Enters keytip mode for this layer\r\n   */\n\n\n  KeytipLayerBase.prototype._enterKeytipMode = function () {\n    if (this._keytipManager.shouldEnterKeytipMode) {\n      this._keytipTree.currentKeytip = this._keytipTree.root; // Show children of root\n\n      this.showKeytips(this._keytipTree.getChildren());\n\n      this._setInKeytipMode(true\n      /* inKeytipMode */\n      );\n\n      if (this.props.onEnterKeytipMode) {\n        this.props.onEnterKeytipMode();\n      }\n    }\n  };\n  /**\r\n   * Exits keytip mode for this layer\r\n   */\n\n\n  KeytipLayerBase.prototype._exitKeytipMode = function (ev) {\n    this._keytipTree.currentKeytip = undefined;\n    this._currentSequence = ''; // Hide all keytips\n\n    this.showKeytips([]); // Reset the delayed keytips if any\n\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout);\n    this._delayedKeytipQueue = [];\n\n    this._setInKeytipMode(false\n    /* inKeytipMode */\n    );\n\n    if (this.props.onExitKeytipMode) {\n      this.props.onExitKeytipMode(ev);\n    }\n  };\n  /**\r\n   * Sets the keytips state property\r\n   *\r\n   * @param keytipProps - Keytips to set in this layer\r\n   */\n\n\n  KeytipLayerBase.prototype._setKeytips = function (keytipProps) {\n    if (keytipProps === void 0) {\n      keytipProps = this._keytipManager.getKeytips();\n    }\n\n    this.setState({\n      keytips: keytipProps,\n      visibleKeytips: this._getVisibleKeytips(keytipProps)\n    });\n  };\n  /**\r\n   * Callback function to use for persisted keytips\r\n   *\r\n   * @param overflowButtonSequences - The overflow button sequence to execute\r\n   * @param keytipSequences - The keytip that should become the 'currentKeytip' when it is registered\r\n   */\n\n\n  KeytipLayerBase.prototype._persistedKeytipExecute = function (overflowButtonSequences, keytipSequences) {\n    // Save newCurrentKeytip for later\n    this._newCurrentKeytipSequences = keytipSequences; // Execute the overflow button's onExecute\n\n    var overflowKeytipNode = this._keytipTree.getNode(sequencesToID(overflowButtonSequences));\n\n    if (overflowKeytipNode && overflowKeytipNode.onExecute) {\n      overflowKeytipNode.onExecute(this._getKtpExecuteTarget(overflowKeytipNode), this._getKtpTarget(overflowKeytipNode));\n    }\n  };\n\n  KeytipLayerBase.prototype._getVisibleKeytips = function (keytips) {\n    // Filter out non-visible keytips and duplicates\n    var seenIds = {};\n    return keytips.filter(function (keytip) {\n      var keytipId = sequencesToID(keytip.keySequences);\n      seenIds[keytipId] = seenIds[keytipId] ? seenIds[keytipId] + 1 : 1;\n      return keytip.visible && seenIds[keytipId] === 1;\n    });\n  };\n  /**\r\n   * Gets the ModifierKeyCodes based on the keyboard event\r\n   *\r\n   * @param ev - React.KeyboardEvent\r\n   * @returns List of ModifierKeyCodes that were pressed\r\n   */\n\n\n  KeytipLayerBase.prototype._getModifierKey = function (key, ev) {\n    var modifierKeys = [];\n\n    if (ev.altKey && key !== 'Alt') {\n      modifierKeys.push(KeytipTransitionModifier.alt);\n    }\n\n    if (ev.ctrlKey && key !== 'Control') {\n      modifierKeys.push(KeytipTransitionModifier.ctrl);\n    }\n\n    if (ev.shiftKey && key !== 'Shift') {\n      modifierKeys.push(KeytipTransitionModifier.shift);\n    }\n\n    if (ev.metaKey && key !== 'Meta') {\n      modifierKeys.push(KeytipTransitionModifier.meta);\n    }\n\n    return modifierKeys.length ? modifierKeys : undefined;\n  };\n  /**\r\n   * Trigger a keytip immediately and set it as the current keytip\r\n   *\r\n   * @param keytipProps - Keytip to trigger immediately\r\n   */\n\n\n  KeytipLayerBase.prototype._triggerKeytipImmediately = function (keytipProps) {\n    // This keytip should become the currentKeytip and should execute right away\n    var keytipSequence = keytipProps.keySequences.slice();\n\n    if (keytipProps.overflowSetSequence) {\n      keytipSequence = mergeOverflows(keytipSequence, keytipProps.overflowSetSequence);\n    } // Set currentKeytip\n\n\n    this._keytipTree.currentKeytip = this._keytipTree.getNode(sequencesToID(keytipSequence));\n\n    if (this._keytipTree.currentKeytip) {\n      // Show all children keytips if any\n      var children = this._keytipTree.getChildren();\n\n      if (children.length) {\n        this.showKeytips(children);\n      }\n\n      if (this._keytipTree.currentKeytip.onExecute) {\n        this._keytipTree.currentKeytip.onExecute(this._getKtpExecuteTarget(this._keytipTree.currentKeytip), this._getKtpTarget(this._keytipTree.currentKeytip));\n      }\n    } // Unset _newCurrKtpSequences\n\n\n    this._newCurrentKeytipSequences = undefined;\n  };\n\n  KeytipLayerBase.prototype._addKeytipToQueue = function (keytipID) {\n    var _this = this; // Add keytip\n\n\n    this._delayedKeytipQueue.push(keytipID); // Clear timeout\n\n\n    this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout); // Reset timeout\n\n    this._delayedQueueTimeout = this._async.setTimeout(function () {\n      if (_this._delayedKeytipQueue.length) {\n        _this.showKeytips(_this._delayedKeytipQueue);\n\n        _this._delayedKeytipQueue = [];\n      }\n    }, 300);\n  };\n\n  KeytipLayerBase.prototype._removeKeytipFromQueue = function (keytipID) {\n    var _this = this;\n\n    var index = this._delayedKeytipQueue.indexOf(keytipID);\n\n    if (index >= 0) {\n      // Remove keytip\n      this._delayedKeytipQueue.splice(index, 1); // Clear timeout\n\n\n      this._delayedQueueTimeout && this._async.clearTimeout(this._delayedQueueTimeout); // Reset timeout\n\n      this._delayedQueueTimeout = this._async.setTimeout(function () {\n        if (_this._delayedKeytipQueue.length) {\n          _this.showKeytips(_this._delayedKeytipQueue);\n\n          _this._delayedKeytipQueue = [];\n        }\n      }, 300);\n    }\n  };\n\n  KeytipLayerBase.prototype._getKtpExecuteTarget = function (currKtp) {\n    return getDocument().querySelector(ktpTargetFromId(currKtp.id));\n  };\n\n  KeytipLayerBase.prototype._getKtpTarget = function (currKtp) {\n    return getDocument().querySelector(ktpTargetFromSequences(currKtp.keySequences));\n  };\n  /**\r\n   * Returns T/F if the keytipProps keySequences match the currentKeytip, and the currentKeytip is in an overflow well\r\n   * This will make 'keytipProps' the new currentKeytip\r\n   *\r\n   * @param keytipProps - Keytip props to check\r\n   * @returns - T/F if this keytip should become the currentKeytip\r\n   */\n\n\n  KeytipLayerBase.prototype._isCurrentKeytipAnAlias = function (keytipProps) {\n    var currKtp = this._keytipTree.currentKeytip;\n\n    if (currKtp && (currKtp.overflowSetSequence || currKtp.persisted) && arraysEqual(keytipProps.keySequences, currKtp.keySequences)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  KeytipLayerBase.defaultProps = {\n    keytipStartSequences: [defaultStartSequence],\n    keytipExitSequences: [defaultExitSequence],\n    keytipReturnSequences: [defaultReturnSequence],\n    content: ''\n  };\n  return KeytipLayerBase;\n}(BaseComponent);\n\nexport { KeytipLayerBase };","map":null,"metadata":{},"sourceType":"module"}