{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow } from '../../Utilities';\nvar RESIZE_DELAY = 500;\nvar MAX_RESIZE_ATTEMPTS = 3;\nexport function withViewport(ComposedComponent) {\n  return (\n    /** @class */\n    function (_super) {\n      tslib_1.__extends(WithViewportComponent, _super);\n\n      function WithViewportComponent(props) {\n        var _this = _super.call(this, props) || this;\n\n        _this._root = React.createRef();\n        /* Note: using lambda here because decorators don't seem to work in decorators. */\n\n        _this._updateViewport = function (withForceUpdate) {\n          var viewport = _this.state.viewport;\n          var viewportElement = _this._root.current;\n          var scrollElement = findScrollableParent(viewportElement);\n          var scrollRect = getRect(scrollElement);\n          var clientRect = getRect(viewportElement);\n\n          var updateComponent = function updateComponent() {\n            if (withForceUpdate && _this._composedComponentInstance) {\n              _this._composedComponentInstance.forceUpdate();\n            }\n          };\n\n          var isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;\n\n          if (isSizeChanged && _this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n            _this._resizeAttempts++;\n\n            _this.setState({\n              viewport: {\n                width: clientRect.width,\n                height: scrollRect.height\n              }\n            }, function () {\n              _this._updateViewport(withForceUpdate);\n            });\n          } else {\n            _this._resizeAttempts = 0;\n            updateComponent();\n          }\n        };\n\n        _this._resizeAttempts = 0;\n        _this.state = {\n          viewport: {\n            width: 0,\n            height: 0\n          }\n        };\n        return _this;\n      }\n\n      WithViewportComponent.prototype.componentDidMount = function () {\n        var skipViewportMeasures = this.props.skipViewportMeasures;\n        this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n          leading: false\n        });\n        var window = getWindow();\n        var viewportElement = this._root.current; // ResizeObserver seems always fire even window is not resized. This is\n        // particularly bad when skipViewportMeasures is set when optimizing fixed layout lists.\n        // It will measure and update and re-render the entire list after list is fully rendered.\n        // So fallback to listen to resize event when skipViewportMeasures is set.\n\n        if (!skipViewportMeasures && window && window.ResizeObserver) {\n          this._viewportResizeObserver = new window.ResizeObserver(this._onAsyncResize);\n\n          this._viewportResizeObserver.observe(viewportElement);\n        } else {\n          this._events.on(window, 'resize', this._onAsyncResize);\n        }\n\n        if (!skipViewportMeasures) {\n          this._updateViewport();\n        }\n      };\n\n      WithViewportComponent.prototype.componentWillUnmount = function () {\n        this._events.dispose();\n\n        if (this._viewportResizeObserver) {\n          this._viewportResizeObserver.disconnect();\n        }\n      };\n\n      WithViewportComponent.prototype.render = function () {\n        var viewport = this.state.viewport;\n        var skipViewportMeasures = this.props.skipViewportMeasures;\n        var isViewportVisible = skipViewportMeasures || viewport.width > 0 && viewport.height > 0;\n        return React.createElement(\"div\", {\n          className: \"ms-Viewport\",\n          ref: this._root,\n          style: {\n            minWidth: 1,\n            minHeight: 1\n          }\n        }, isViewportVisible && React.createElement(ComposedComponent, tslib_1.__assign({\n          ref: this._updateComposedComponentRef,\n          viewport: viewport\n        }, this.props)));\n      };\n\n      WithViewportComponent.prototype.forceUpdate = function () {\n        this._updateViewport(true);\n      };\n\n      WithViewportComponent.prototype._onAsyncResize = function () {\n        this._updateViewport();\n      };\n\n      return WithViewportComponent;\n    }(BaseDecorator)\n  );\n}","map":null,"metadata":{},"sourceType":"module"}