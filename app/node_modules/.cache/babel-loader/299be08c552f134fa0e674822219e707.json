{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseComponent, KeyCodes, assign, elementContains, getRTLSafeKeyCode, classNamesFunction } from '../../Utilities';\nimport { CheckboxVisibility, ColumnActionsMode, ConstrainMode, DetailsListLayoutMode, ColumnDragEndLocation } from '../DetailsList/DetailsList.types';\nimport { DetailsHeader } from '../DetailsList/DetailsHeader';\nimport { SelectAllVisibility } from '../DetailsList/DetailsHeader.types';\nimport { DetailsRow } from '../DetailsList/DetailsRow';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Selection, SelectionMode, SelectionZone } from '../../utilities/selection/index';\nimport { DragDropHelper } from '../../utilities/dragdrop/DragDropHelper';\nimport { GroupedList } from '../../GroupedList';\nimport { List } from '../../List';\nimport { withViewport } from '../../utilities/decorators/withViewport';\nimport { GetGroupCount } from '../../utilities/groupedList/GroupedListUtility';\nimport { DEFAULT_CELL_STYLE_PROPS } from './DetailsRow.styles'; // For every group level there is a GroupSpacer added. Importing this const to have the source value in one place.\n\nimport { SPACER_WIDTH as GROUP_EXPAND_WIDTH } from '../GroupedList/GroupSpacer';\nvar getClassNames = classNamesFunction();\nvar MIN_COLUMN_WIDTH = 100; // this is the global min width\n\nvar CHECKBOX_WIDTH = 40;\nvar DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nvar DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nvar SHIMMER_INITIAL_ITEMS = 10;\nvar SHIMMER_ITEMS = new Array(SHIMMER_INITIAL_ITEMS);\n\nvar DetailsListBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DetailsListBase, _super);\n\n  function DetailsListBase(props) {\n    var _this = _super.call(this, props) || this; // References\n\n\n    _this._root = React.createRef();\n    _this._header = React.createRef();\n    _this._groupedList = React.createRef();\n    _this._list = React.createRef();\n    _this._focusZone = React.createRef();\n    _this._selectionZone = React.createRef();\n\n    _this._onRenderRow = function (props, defaultRender) {\n      return React.createElement(DetailsRow, tslib_1.__assign({}, props));\n    };\n\n    _this._onRenderDetailsHeader = function (detailsHeaderProps, defaultRender) {\n      return React.createElement(DetailsHeader, tslib_1.__assign({}, detailsHeaderProps));\n    };\n\n    _this._onRenderDetailsFooter = function (detailsFooterProps, defaultRender) {\n      return null;\n    };\n\n    _this._onRenderListCell = function (nestingDepth) {\n      return function (item, itemIndex) {\n        return _this._onRenderCell(nestingDepth, item, itemIndex);\n      };\n    };\n\n    _this._activeRows = {};\n    _this._columnOverrides = {};\n    _this._onColumnIsSizingChanged = _this._onColumnIsSizingChanged.bind(_this);\n    _this._onColumnResized = _this._onColumnResized.bind(_this);\n    _this._onColumnAutoResized = _this._onColumnAutoResized.bind(_this);\n    _this._onRowDidMount = _this._onRowDidMount.bind(_this);\n    _this._onRowWillUnmount = _this._onRowWillUnmount.bind(_this);\n    _this._onToggleCollapse = _this._onToggleCollapse.bind(_this);\n    _this._onActiveRowChanged = _this._onActiveRowChanged.bind(_this);\n    _this._onBlur = _this._onBlur.bind(_this);\n    _this._onHeaderKeyDown = _this._onHeaderKeyDown.bind(_this);\n    _this._onContentKeyDown = _this._onContentKeyDown.bind(_this);\n    _this._onRenderCell = _this._onRenderCell.bind(_this);\n    _this._onGroupExpandStateChanged = _this._onGroupExpandStateChanged.bind(_this);\n    _this._onColumnDragEnd = _this._onColumnDragEnd.bind(_this);\n    _this.state = {\n      focusedItemIndex: -1,\n      lastWidth: 0,\n      adjustedColumns: _this._getAdjustedColumns(props),\n      isSizing: false,\n      isDropping: false,\n      isCollapsed: props.groupProps && props.groupProps.isAllGroupsCollapsed,\n      isSomeGroupExpanded: props.groupProps && !props.groupProps.isAllGroupsCollapsed\n    };\n    _this._selection = props.selection || new Selection({\n      onSelectionChanged: undefined,\n      getKey: props.getKey\n    });\n\n    if (!_this.props.disableSelectionZone) {\n      _this._selection.setItems(props.items, false);\n    }\n\n    _this._dragDropHelper = props.dragDropEvents ? new DragDropHelper({\n      selection: _this._selection,\n      minimumPixelsForDrag: props.minimumPixelsForDrag\n    }) : undefined;\n    _this._initialFocusedIndex = props.initialFocusedIndex;\n    return _this;\n  }\n\n  DetailsListBase.prototype.scrollToIndex = function (index, measureItem, scrollToMode) {\n    this._list.current && this._list.current.scrollToIndex(index, measureItem, scrollToMode);\n    this._groupedList.current && this._groupedList.current.scrollToIndex(index, measureItem, scrollToMode);\n  };\n\n  DetailsListBase.prototype.focusIndex = function (index, forceIntoFirstElement, measureItem, scrollToMode) {\n    if (forceIntoFirstElement === void 0) {\n      forceIntoFirstElement = false;\n    }\n\n    var item = this.props.items[index];\n\n    if (item) {\n      this.scrollToIndex(index, measureItem, scrollToMode);\n\n      var itemKey = this._getItemKey(item, index);\n\n      var row = this._activeRows[itemKey];\n\n      if (row) {\n        this._setFocusToRow(row, forceIntoFirstElement);\n      }\n    }\n  };\n\n  DetailsListBase.prototype.getStartItemIndexInView = function () {\n    if (this._list && this._list.current) {\n      return this._list.current.getStartItemIndexInView();\n    } else if (this._groupedList && this._groupedList.current) {\n      return this._groupedList.current.getStartItemIndexInView();\n    }\n\n    return 0;\n  };\n\n  DetailsListBase.prototype.componentWillUnmount = function () {\n    if (this._dragDropHelper) {\n      // TODO If the DragDropHelper was passed via props, this will dispose it, which is incorrect behavior.\n      this._dragDropHelper.dispose();\n    }\n  };\n\n  DetailsListBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this._initialFocusedIndex !== undefined) {\n      var item = this.props.items[this._initialFocusedIndex];\n\n      if (item) {\n        var itemKey = this._getItemKey(item, this._initialFocusedIndex);\n\n        var row = this._activeRows[itemKey];\n\n        if (row) {\n          this._setFocusToRowIfPending(row);\n        }\n      }\n    }\n\n    if (this.props.items !== prevProps.items && this.props.items.length > 0 && this.state.focusedItemIndex !== -1 && !elementContains(this._root.current, document.activeElement, false)) {\n      // Item set has changed and previously-focused item is gone.\n      // Set focus to item at index of previously-focused item if it is in range,\n      // else set focus to the last item.\n      var index = this.state.focusedItemIndex < this.props.items.length ? this.state.focusedItemIndex : this.props.items.length - 1;\n      var item = this.props.items[index];\n\n      var itemKey = this._getItemKey(item, this.state.focusedItemIndex);\n\n      var row = this._activeRows[itemKey];\n\n      if (row) {\n        this._setFocusToRow(row);\n      } else {\n        this._initialFocusedIndex = index;\n      }\n    }\n\n    if (this.props.onDidUpdate) {\n      this.props.onDidUpdate(this);\n    }\n  };\n\n  DetailsListBase.prototype.componentWillReceiveProps = function (newProps) {\n    var _a = this.props,\n        checkboxVisibility = _a.checkboxVisibility,\n        items = _a.items,\n        setKey = _a.setKey,\n        _b = _a.selectionMode,\n        selectionMode = _b === void 0 ? this._selection.mode : _b,\n        columns = _a.columns,\n        viewport = _a.viewport,\n        compact = _a.compact,\n        dragDropEvents = _a.dragDropEvents;\n    var _c = (this.props.groupProps || {}).isAllGroupsCollapsed,\n        isAllGroupsCollapsed = _c === void 0 ? undefined : _c;\n    var shouldResetSelection = newProps.setKey !== setKey || newProps.setKey === undefined;\n    var shouldForceUpdates = false;\n\n    if (newProps.layoutMode !== this.props.layoutMode) {\n      shouldForceUpdates = true;\n    }\n\n    if (shouldResetSelection) {\n      this._initialFocusedIndex = newProps.initialFocusedIndex; // reset focusedItemIndex when setKey changes\n\n      this.setState({\n        focusedItemIndex: this._initialFocusedIndex !== undefined ? this._initialFocusedIndex : -1\n      });\n    }\n\n    if (!this.props.disableSelectionZone && newProps.items !== items) {\n      this._selection.setItems(newProps.items, shouldResetSelection);\n    }\n\n    if (newProps.checkboxVisibility !== checkboxVisibility || newProps.columns !== columns || newProps.viewport.width !== viewport.width || newProps.compact !== compact) {\n      shouldForceUpdates = true;\n    }\n\n    this._adjustColumns(newProps, true);\n\n    if (newProps.selectionMode !== selectionMode) {\n      shouldForceUpdates = true;\n    }\n\n    if (isAllGroupsCollapsed === undefined && newProps.groupProps && newProps.groupProps.isAllGroupsCollapsed !== undefined) {\n      this.setState({\n        isCollapsed: newProps.groupProps.isAllGroupsCollapsed,\n        isSomeGroupExpanded: !newProps.groupProps.isAllGroupsCollapsed\n      });\n    }\n\n    if (newProps.dragDropEvents !== dragDropEvents) {\n      this._dragDropHelper && this._dragDropHelper.dispose();\n      this._dragDropHelper = newProps.dragDropEvents ? new DragDropHelper({\n        selection: this._selection,\n        minimumPixelsForDrag: newProps.minimumPixelsForDrag\n      }) : undefined;\n      shouldForceUpdates = true;\n    }\n\n    if (shouldForceUpdates) {\n      this._pendingForceUpdate = true;\n    }\n  };\n\n  DetailsListBase.prototype.componentWillUpdate = function () {\n    if (this._pendingForceUpdate) {\n      this._forceListUpdates();\n    }\n  };\n\n  DetailsListBase.prototype.render = function () {\n    var _a = this.props,\n        ariaLabelForListHeader = _a.ariaLabelForListHeader,\n        ariaLabelForSelectAllCheckbox = _a.ariaLabelForSelectAllCheckbox,\n        ariaLabelForSelectionColumn = _a.ariaLabelForSelectionColumn,\n        className = _a.className,\n        checkboxVisibility = _a.checkboxVisibility,\n        compact = _a.compact,\n        constrainMode = _a.constrainMode,\n        dragDropEvents = _a.dragDropEvents,\n        groups = _a.groups,\n        groupProps = _a.groupProps,\n        indentWidth = _a.indentWidth,\n        items = _a.items,\n        isHeaderVisible = _a.isHeaderVisible,\n        layoutMode = _a.layoutMode,\n        onItemInvoked = _a.onItemInvoked,\n        onItemContextMenu = _a.onItemContextMenu,\n        onColumnHeaderClick = _a.onColumnHeaderClick,\n        onColumnHeaderContextMenu = _a.onColumnHeaderContextMenu,\n        _b = _a.selectionMode,\n        selectionMode = _b === void 0 ? this._selection.mode : _b,\n        selectionPreservedOnEmptyClick = _a.selectionPreservedOnEmptyClick,\n        selectionZoneProps = _a.selectionZoneProps,\n        ariaLabel = _a.ariaLabel,\n        ariaLabelForGrid = _a.ariaLabelForGrid,\n        rowElementEventMap = _a.rowElementEventMap,\n        _c = _a.shouldApplyApplicationRole,\n        shouldApplyApplicationRole = _c === void 0 ? false : _c,\n        getKey = _a.getKey,\n        listProps = _a.listProps,\n        usePageCache = _a.usePageCache,\n        onShouldVirtualize = _a.onShouldVirtualize,\n        enableShimmer = _a.enableShimmer,\n        viewport = _a.viewport,\n        minimumPixelsForDrag = _a.minimumPixelsForDrag,\n        getGroupHeight = _a.getGroupHeight,\n        styles = _a.styles,\n        theme = _a.theme,\n        _d = _a.cellStyleProps,\n        cellStyleProps = _d === void 0 ? DEFAULT_CELL_STYLE_PROPS : _d;\n    var _e = this.state,\n        adjustedColumns = _e.adjustedColumns,\n        isCollapsed = _e.isCollapsed,\n        isSizing = _e.isSizing,\n        isSomeGroupExpanded = _e.isSomeGroupExpanded;\n\n    var _f = this,\n        selection = _f._selection,\n        dragDropHelper = _f._dragDropHelper;\n\n    var groupNestingDepth = this._getGroupNestingDepth();\n\n    var additionalListProps = tslib_1.__assign({\n      renderedWindowsAhead: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_AHEAD,\n      renderedWindowsBehind: isSizing ? 0 : DEFAULT_RENDERED_WINDOWS_BEHIND,\n      getKey: getKey\n    }, listProps);\n\n    var selectAllVisibility = SelectAllVisibility.none; // for SelectionMode.none\n\n    if (selectionMode === SelectionMode.single) {\n      selectAllVisibility = SelectAllVisibility.hidden;\n    }\n\n    if (selectionMode === SelectionMode.multiple) {\n      // if isCollapsedGroupSelectVisible is false, disable select all when the list has all collapsed groups\n      var isCollapsedGroupSelectVisible = groupProps && groupProps.headerProps && groupProps.headerProps.isCollapsedGroupSelectVisible;\n\n      if (isCollapsedGroupSelectVisible === undefined) {\n        isCollapsedGroupSelectVisible = true;\n      }\n\n      var isSelectAllVisible = isCollapsedGroupSelectVisible || !groups || isSomeGroupExpanded;\n      selectAllVisibility = isSelectAllVisible ? SelectAllVisibility.visible : SelectAllVisibility.hidden;\n    }\n\n    if (checkboxVisibility === CheckboxVisibility.hidden) {\n      selectAllVisibility = SelectAllVisibility.none;\n    }\n\n    var _g = this.props,\n        _h = _g.onRenderDetailsHeader,\n        onRenderDetailsHeader = _h === void 0 ? this._onRenderDetailsHeader : _h,\n        _j = _g.onRenderDetailsFooter,\n        onRenderDetailsFooter = _j === void 0 ? this._onRenderDetailsFooter : _j;\n\n    var detailsFooterProps = this._getDetailsFooterProps();\n\n    var columnReorderProps = this._getColumnReorderProps();\n\n    var rowCount = (isHeaderVisible ? 1 : 0) + GetGroupCount(groups) + (items ? items.length : 0);\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      compact: compact,\n      isFixed: layoutMode === DetailsListLayoutMode.fixedColumns,\n      isHorizontalConstrained: constrainMode === ConstrainMode.horizontalConstrained,\n      className: className\n    });\n    var list = groups ? React.createElement(GroupedList, {\n      componentRef: this._groupedList,\n      groups: groups,\n      groupProps: groupProps ? this._getGroupProps(groupProps) : undefined,\n      items: items,\n      onRenderCell: this._onRenderCell,\n      selection: selection,\n      selectionMode: checkboxVisibility !== CheckboxVisibility.hidden ? selectionMode : SelectionMode.none,\n      dragDropEvents: dragDropEvents,\n      dragDropHelper: dragDropHelper,\n      eventsToRegister: rowElementEventMap,\n      listProps: additionalListProps,\n      onGroupExpandStateChanged: this._onGroupExpandStateChanged,\n      usePageCache: usePageCache,\n      onShouldVirtualize: onShouldVirtualize,\n      getGroupHeight: getGroupHeight,\n      compact: compact\n    }) : React.createElement(List, tslib_1.__assign({\n      ref: this._list,\n      role: \"presentation\",\n      items: enableShimmer && !items.length ? SHIMMER_ITEMS : items,\n      onRenderCell: this._onRenderListCell(0),\n      usePageCache: usePageCache,\n      onShouldVirtualize: onShouldVirtualize\n    }, additionalListProps));\n    return (// If shouldApplyApplicationRole is true, role application will be applied to make arrow keys work\n      // with JAWS.\n      React.createElement(\"div\", tslib_1.__assign({\n        ref: this._root,\n        className: classNames.root,\n        \"data-automationid\": \"DetailsList\",\n        \"data-is-scrollable\": \"false\",\n        \"aria-label\": ariaLabel\n      }, shouldApplyApplicationRole ? {\n        role: 'application'\n      } : {}), React.createElement(\"div\", {\n        role: \"grid\",\n        \"aria-label\": ariaLabelForGrid,\n        \"aria-rowcount\": rowCount,\n        \"aria-colcount\": (selectAllVisibility !== SelectAllVisibility.none ? 1 : 0) + (adjustedColumns ? adjustedColumns.length : 0),\n        \"aria-readonly\": \"true\"\n      }, React.createElement(\"div\", {\n        onKeyDown: this._onHeaderKeyDown,\n        role: \"presentation\",\n        className: classNames.headerWrapper\n      }, isHeaderVisible && onRenderDetailsHeader({\n        componentRef: this._header,\n        selectionMode: selectionMode,\n        layoutMode: layoutMode,\n        selection: selection,\n        columns: adjustedColumns,\n        onColumnClick: onColumnHeaderClick,\n        onColumnContextMenu: onColumnHeaderContextMenu,\n        onColumnResized: this._onColumnResized,\n        onColumnIsSizingChanged: this._onColumnIsSizingChanged,\n        onColumnAutoResized: this._onColumnAutoResized,\n        groupNestingDepth: groupNestingDepth,\n        isAllCollapsed: isCollapsed,\n        onToggleCollapseAll: this._onToggleCollapse,\n        ariaLabel: ariaLabelForListHeader,\n        ariaLabelForSelectAllCheckbox: ariaLabelForSelectAllCheckbox,\n        ariaLabelForSelectionColumn: ariaLabelForSelectionColumn,\n        selectAllVisibility: selectAllVisibility,\n        collapseAllVisibility: groupProps && groupProps.collapseAllVisibility,\n        viewport: viewport,\n        columnReorderProps: columnReorderProps,\n        minimumPixelsForDrag: minimumPixelsForDrag,\n        cellStyleProps: cellStyleProps,\n        checkboxVisibility: checkboxVisibility,\n        indentWidth: indentWidth\n      }, this._onRenderDetailsHeader)), React.createElement(\"div\", {\n        onKeyDown: this._onContentKeyDown,\n        role: \"presentation\",\n        className: classNames.contentWrapper\n      }, React.createElement(FocusZone, {\n        componentRef: this._focusZone,\n        className: classNames.focusZone,\n        direction: FocusZoneDirection.vertical,\n        isInnerZoneKeystroke: isRightArrow,\n        onActiveElementChanged: this._onActiveRowChanged,\n        onBlur: this._onBlur\n      }, !this.props.disableSelectionZone ? React.createElement(SelectionZone, tslib_1.__assign({\n        ref: this._selectionZone,\n        selection: selection,\n        selectionPreservedOnEmptyClick: selectionPreservedOnEmptyClick,\n        selectionMode: selectionMode,\n        onItemInvoked: onItemInvoked,\n        onItemContextMenu: onItemContextMenu,\n        enterModalOnTouch: this.props.enterModalSelectionOnTouch\n      }, selectionZoneProps || {}), list) : list)), onRenderDetailsFooter(tslib_1.__assign({}, detailsFooterProps), this._onRenderDetailsFooter)))\n    );\n  };\n\n  DetailsListBase.prototype.forceUpdate = function () {\n    _super.prototype.forceUpdate.call(this);\n\n    this._forceListUpdates();\n  };\n\n  DetailsListBase.prototype._onRenderCell = function (nestingDepth, item, index) {\n    var _a = this.props,\n        compact = _a.compact,\n        dragDropEvents = _a.dragDropEvents,\n        eventsToRegister = _a.rowElementEventMap,\n        onRenderMissingItem = _a.onRenderMissingItem,\n        onRenderItemColumn = _a.onRenderItemColumn,\n        _b = _a.onRenderRow,\n        onRenderRow = _b === void 0 ? this._onRenderRow : _b,\n        _c = _a.selectionMode,\n        selectionMode = _c === void 0 ? this._selection.mode : _c,\n        viewport = _a.viewport,\n        checkboxVisibility = _a.checkboxVisibility,\n        getRowAriaLabel = _a.getRowAriaLabel,\n        getRowAriaDescribedBy = _a.getRowAriaDescribedBy,\n        checkButtonAriaLabel = _a.checkButtonAriaLabel,\n        checkboxCellClassName = _a.checkboxCellClassName,\n        groupProps = _a.groupProps,\n        useReducedRowRenderer = _a.useReducedRowRenderer,\n        indentWidth = _a.indentWidth,\n        _d = _a.cellStyleProps,\n        cellStyleProps = _d === void 0 ? DEFAULT_CELL_STYLE_PROPS : _d;\n    var collapseAllVisibility = groupProps && groupProps.collapseAllVisibility;\n    var selection = this._selection;\n    var dragDropHelper = this._dragDropHelper;\n    var columns = this.state.adjustedColumns;\n    var rowProps = {\n      item: item,\n      itemIndex: index,\n      compact: compact,\n      columns: columns,\n      groupNestingDepth: nestingDepth,\n      selectionMode: selectionMode,\n      selection: selection,\n      onDidMount: this._onRowDidMount,\n      onWillUnmount: this._onRowWillUnmount,\n      onRenderItemColumn: onRenderItemColumn,\n      eventsToRegister: eventsToRegister,\n      dragDropEvents: dragDropEvents,\n      dragDropHelper: dragDropHelper,\n      viewport: viewport,\n      checkboxVisibility: checkboxVisibility,\n      collapseAllVisibility: collapseAllVisibility,\n      getRowAriaLabel: getRowAriaLabel,\n      getRowAriaDescribedBy: getRowAriaDescribedBy,\n      checkButtonAriaLabel: checkButtonAriaLabel,\n      checkboxCellClassName: checkboxCellClassName,\n      useReducedRowRenderer: useReducedRowRenderer,\n      indentWidth: indentWidth,\n      cellStyleProps: cellStyleProps\n    };\n\n    if (!item) {\n      if (onRenderMissingItem) {\n        return onRenderMissingItem(index, rowProps);\n      }\n\n      return null;\n    }\n\n    return onRenderRow(rowProps, this._onRenderRow);\n  };\n\n  DetailsListBase.prototype._onGroupExpandStateChanged = function (isSomeGroupExpanded) {\n    this.setState({\n      isSomeGroupExpanded: isSomeGroupExpanded\n    });\n  };\n\n  DetailsListBase.prototype._onColumnIsSizingChanged = function (column, isSizing) {\n    this.setState({\n      isSizing: isSizing\n    });\n  };\n\n  DetailsListBase.prototype._onHeaderKeyDown = function (ev) {\n    if (ev.which === KeyCodes.down) {\n      if (this._focusZone.current && this._focusZone.current.focus()) {\n        // select the first item in list after down arrow key event\n        this._selection.setIndexSelected(0, true, false);\n\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  DetailsListBase.prototype._onContentKeyDown = function (ev) {\n    if (ev.which === KeyCodes.up && !ev.altKey) {\n      if (this._header.current && this._header.current.focus()) {\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  DetailsListBase.prototype._getGroupNestingDepth = function () {\n    var groups = this.props.groups;\n    var level = 0;\n    var groupsInLevel = groups;\n\n    while (groupsInLevel && groupsInLevel.length > 0) {\n      level++;\n      groupsInLevel = groupsInLevel[0].children;\n    }\n\n    return level;\n  };\n\n  DetailsListBase.prototype._onRowDidMount = function (row) {\n    var _a = row.props,\n        item = _a.item,\n        itemIndex = _a.itemIndex;\n\n    var itemKey = this._getItemKey(item, itemIndex);\n\n    this._activeRows[itemKey] = row; // this is used for column auto resize\n\n    this._setFocusToRowIfPending(row);\n\n    var onRowDidMount = this.props.onRowDidMount;\n\n    if (onRowDidMount) {\n      onRowDidMount(item, itemIndex);\n    }\n  };\n\n  DetailsListBase.prototype._setFocusToRowIfPending = function (row) {\n    var itemIndex = row.props.itemIndex;\n\n    if (this._initialFocusedIndex !== undefined && itemIndex === this._initialFocusedIndex) {\n      this._setFocusToRow(row);\n\n      delete this._initialFocusedIndex;\n    }\n  };\n\n  DetailsListBase.prototype._setFocusToRow = function (row, forceIntoFirstElement) {\n    if (forceIntoFirstElement === void 0) {\n      forceIntoFirstElement = false;\n    }\n\n    if (this._selectionZone.current) {\n      this._selectionZone.current.ignoreNextFocus();\n    }\n\n    this._async.setTimeout(function () {\n      row.focus(forceIntoFirstElement);\n    }, 0);\n  };\n\n  DetailsListBase.prototype._onRowWillUnmount = function (row) {\n    var onRowWillUnmount = this.props.onRowWillUnmount;\n    var _a = row.props,\n        item = _a.item,\n        itemIndex = _a.itemIndex;\n\n    var itemKey = this._getItemKey(item, itemIndex);\n\n    delete this._activeRows[itemKey];\n\n    if (onRowWillUnmount) {\n      onRowWillUnmount(item, itemIndex);\n    }\n  };\n\n  DetailsListBase.prototype._onToggleCollapse = function (collapsed) {\n    this.setState({\n      isCollapsed: collapsed\n    });\n\n    if (this._groupedList.current) {\n      this._groupedList.current.toggleCollapseAll(collapsed);\n    }\n  };\n\n  DetailsListBase.prototype._onColumnDragEnd = function (props, event) {\n    var columnReorderOptions = this.props.columnReorderOptions;\n    var finalDropLocation = ColumnDragEndLocation.outside;\n\n    if (columnReorderOptions && columnReorderOptions.onDragEnd) {\n      if (props.dropLocation && props.dropLocation !== ColumnDragEndLocation.header) {\n        finalDropLocation = props.dropLocation;\n      } else if (this._root.current) {\n        var clientRect = this._root.current.getBoundingClientRect();\n\n        if (event.clientX > clientRect.left && event.clientX < clientRect.right && event.clientY > clientRect.top && event.clientY < clientRect.bottom) {\n          finalDropLocation = ColumnDragEndLocation.surface;\n        }\n      }\n\n      columnReorderOptions.onDragEnd(finalDropLocation);\n    }\n  };\n\n  DetailsListBase.prototype._forceListUpdates = function () {\n    this._pendingForceUpdate = false;\n\n    if (this._groupedList.current) {\n      this._groupedList.current.forceUpdate();\n    }\n\n    if (this._list.current) {\n      this._list.current.forceUpdate();\n    }\n  };\n\n  DetailsListBase.prototype._notifyColumnsResized = function () {\n    this.state.adjustedColumns.forEach(function (column) {\n      if (column.onColumnResize) {\n        column.onColumnResize(column.currentWidth);\n      }\n    });\n  };\n\n  DetailsListBase.prototype._adjustColumns = function (newProps, forceUpdate, resizingColumnIndex) {\n    var adjustedColumns = this._getAdjustedColumns(newProps, forceUpdate, resizingColumnIndex);\n\n    var viewportWidth = this.props.viewport.width;\n\n    if (adjustedColumns) {\n      this.setState({\n        adjustedColumns: adjustedColumns,\n        lastWidth: viewportWidth\n      }, this._notifyColumnsResized);\n    }\n  };\n  /** Returns adjusted columns, given the viewport size and layout mode. */\n\n\n  DetailsListBase.prototype._getAdjustedColumns = function (newProps, forceUpdate, resizingColumnIndex) {\n    var _this = this;\n\n    var newItems = newProps.items,\n        layoutMode = newProps.layoutMode,\n        selectionMode = newProps.selectionMode;\n    var newColumns = newProps.columns;\n    var viewportWidth = newProps.viewport.width;\n    var columns = this.props ? this.props.columns : [];\n    var lastWidth = this.state ? this.state.lastWidth : -1;\n    var lastSelectionMode = this.state ? this.state.lastSelectionMode : undefined;\n\n    if (viewportWidth !== undefined) {\n      if (!forceUpdate && lastWidth === viewportWidth && lastSelectionMode === selectionMode && (!columns || newColumns === columns)) {\n        return [];\n      }\n    } else {\n      viewportWidth = this.props.viewport.width;\n    }\n\n    newColumns = newColumns || buildColumns(newItems, true);\n    var adjustedColumns;\n\n    if (layoutMode === DetailsListLayoutMode.fixedColumns) {\n      adjustedColumns = this._getFixedColumns(newColumns); // Preserve adjusted column calculated widths.\n\n      adjustedColumns.forEach(function (column) {\n        _this._rememberCalculatedWidth(column, column.calculatedWidth);\n      });\n    } else {\n      if (resizingColumnIndex !== undefined) {\n        adjustedColumns = this._getJustifiedColumnsAfterResize(newColumns, viewportWidth, newProps, resizingColumnIndex);\n      } else {\n        adjustedColumns = this._getJustifiedColumns(newColumns, viewportWidth, newProps, 0);\n      }\n\n      adjustedColumns.forEach(function (column) {\n        _this._getColumnOverride(column.key).currentWidth = column.calculatedWidth;\n      });\n    }\n\n    return adjustedColumns;\n  };\n  /** Builds a set of columns based on the given columns mixed with the current overrides. */\n\n\n  DetailsListBase.prototype._getFixedColumns = function (newColumns) {\n    var _this = this;\n\n    return newColumns.map(function (column) {\n      var newColumn = assign({}, column, _this._columnOverrides[column.key]);\n\n      if (!newColumn.calculatedWidth) {\n        newColumn.calculatedWidth = newColumn.maxWidth || newColumn.minWidth || MIN_COLUMN_WIDTH;\n      }\n\n      return newColumn;\n    });\n  };\n\n  DetailsListBase.prototype._getJustifiedColumnsAfterResize = function (newColumns, viewportWidth, props, resizingColumnIndex) {\n    var _this = this;\n\n    var fixedColumns = newColumns.slice(0, resizingColumnIndex);\n    fixedColumns.forEach(function (column) {\n      return column.calculatedWidth = _this._getColumnOverride(column.key).currentWidth;\n    });\n    var fixedWidth = fixedColumns.reduce(function (total, column, i) {\n      return total + getPaddedWidth(column, i === 0, props);\n    }, 0);\n    var remainingColumns = newColumns.slice(resizingColumnIndex);\n    var remainingWidth = viewportWidth - fixedWidth;\n    return fixedColumns.concat(this._getJustifiedColumns(remainingColumns, remainingWidth, props, resizingColumnIndex));\n  };\n  /** Builds a set of columns to fix within the viewport width. */\n\n\n  DetailsListBase.prototype._getJustifiedColumns = function (newColumns, viewportWidth, props, firstIndex) {\n    var _this = this;\n\n    var _a = props.selectionMode,\n        selectionMode = _a === void 0 ? this._selection.mode : _a,\n        checkboxVisibility = props.checkboxVisibility;\n    var rowCheckWidth = selectionMode !== SelectionMode.none && checkboxVisibility !== CheckboxVisibility.hidden ? CHECKBOX_WIDTH : 0;\n    var groupExpandWidth = this._getGroupNestingDepth() * GROUP_EXPAND_WIDTH;\n    var totalWidth = 0; // offset because we have one less inner padding.\n\n    var availableWidth = viewportWidth - (rowCheckWidth + groupExpandWidth);\n    var adjustedColumns = newColumns.map(function (column, i) {\n      var newColumn = tslib_1.__assign({}, column, {\n        calculatedWidth: column.minWidth || MIN_COLUMN_WIDTH\n      }, _this._columnOverrides[column.key]);\n\n      var isFirst = i + firstIndex === 0;\n      totalWidth += getPaddedWidth(newColumn, isFirst, props);\n      return newColumn;\n    });\n    var lastIndex = adjustedColumns.length - 1; // Shrink or remove collapsable columns.\n\n    while (lastIndex > 0 && totalWidth > availableWidth) {\n      var column = adjustedColumns[lastIndex];\n      var minWidth = column.minWidth || MIN_COLUMN_WIDTH;\n      var overflowWidth = totalWidth - availableWidth;\n\n      if (column.calculatedWidth - minWidth >= overflowWidth || !(column.isCollapsable || column.isCollapsible)) {\n        column.calculatedWidth = Math.max(column.calculatedWidth - overflowWidth, minWidth);\n        totalWidth = availableWidth;\n      } else {\n        totalWidth -= getPaddedWidth(column, false, props);\n        adjustedColumns.splice(lastIndex, 1);\n      }\n\n      lastIndex--;\n    } // Then expand columns starting at the beginning, until we've filled the width.\n\n\n    for (var i = 0; i < adjustedColumns.length && totalWidth < availableWidth; i++) {\n      var column = adjustedColumns[i];\n      var isLast = i === adjustedColumns.length - 1;\n      var overrides = this._columnOverrides[column.key];\n\n      if (overrides && overrides.calculatedWidth && !isLast) {\n        continue;\n      }\n\n      var spaceLeft = availableWidth - totalWidth;\n      var increment = void 0;\n\n      if (isLast) {\n        increment = spaceLeft;\n      } else {\n        var maxWidth = column.maxWidth;\n        var minWidth = column.minWidth || maxWidth || MIN_COLUMN_WIDTH;\n        increment = maxWidth ? Math.min(spaceLeft, maxWidth - minWidth) : spaceLeft;\n      }\n\n      column.calculatedWidth = column.calculatedWidth + increment;\n      totalWidth += increment;\n    }\n\n    return adjustedColumns;\n  };\n\n  DetailsListBase.prototype._onColumnResized = function (resizingColumn, newWidth, resizingColumnIndex) {\n    var newCalculatedWidth = Math.max(resizingColumn.minWidth || MIN_COLUMN_WIDTH, newWidth);\n\n    if (this.props.onColumnResize) {\n      this.props.onColumnResize(resizingColumn, newCalculatedWidth, resizingColumnIndex);\n    }\n\n    this._rememberCalculatedWidth(resizingColumn, newCalculatedWidth);\n\n    this._adjustColumns(this.props, true, resizingColumnIndex);\n\n    this._forceListUpdates();\n  };\n\n  DetailsListBase.prototype._rememberCalculatedWidth = function (column, newCalculatedWidth) {\n    var overrides = this._getColumnOverride(column.key);\n\n    overrides.calculatedWidth = newCalculatedWidth;\n    overrides.currentWidth = newCalculatedWidth;\n  };\n\n  DetailsListBase.prototype._getColumnOverride = function (key) {\n    return this._columnOverrides[key] = this._columnOverrides[key] || {};\n  };\n  /**\r\n   * Callback function when double clicked on the details header column resizer\r\n   * which will measure the column cells of all the active rows and resize the\r\n   * column to the max cell width.\r\n   *\r\n   * @private\r\n   * @param {IColumn} column (double clicked column definition)\r\n   * @param {number} columnIndex (double clicked column index)\r\n   * @todo min width 100 should be changed to const value and should be consistent with the\r\n   * value used on _onSizerMove method in DetailsHeader\r\n   */\n\n\n  DetailsListBase.prototype._onColumnAutoResized = function (column, columnIndex) {\n    var _this = this;\n\n    var max = 0;\n    var count = 0;\n    var totalCount = Object.keys(this._activeRows).length;\n\n    for (var key in this._activeRows) {\n      if (this._activeRows.hasOwnProperty(key)) {\n        var currentRow = this._activeRows[key];\n        currentRow.measureCell(columnIndex, function (width) {\n          max = Math.max(max, width);\n          count++;\n\n          if (count === totalCount) {\n            _this._onColumnResized(column, max, columnIndex);\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Call back function when an element in FocusZone becomes active. It will translate it into item\r\n   * and call onActiveItemChanged callback if specified.\r\n   *\r\n   * @private\r\n   * @param {el} row element that became active in Focus Zone\r\n   * @param {ev} focus event from Focus Zone\r\n   */\n\n\n  DetailsListBase.prototype._onActiveRowChanged = function (el, ev) {\n    var _a = this.props,\n        items = _a.items,\n        onActiveItemChanged = _a.onActiveItemChanged;\n\n    if (!el) {\n      return;\n    } // Check and assign index only if the event was raised from any DetailsRow element\n\n\n    if (el.getAttribute('data-item-index')) {\n      var index = Number(el.getAttribute('data-item-index'));\n\n      if (index >= 0) {\n        if (onActiveItemChanged) {\n          onActiveItemChanged(items[index], index, ev);\n        }\n\n        this.setState({\n          focusedItemIndex: index\n        });\n      }\n    }\n  };\n\n  DetailsListBase.prototype._onBlur = function (event) {\n    this.setState({\n      focusedItemIndex: -1\n    });\n  };\n\n  DetailsListBase.prototype._getItemKey = function (item, itemIndex) {\n    var getKey = this.props.getKey;\n    var itemKey = undefined;\n\n    if (item) {\n      itemKey = item.key;\n    }\n\n    if (getKey) {\n      itemKey = getKey(item, itemIndex);\n    }\n\n    if (!itemKey) {\n      itemKey = itemIndex;\n    }\n\n    return itemKey;\n  };\n\n  DetailsListBase.prototype._getDetailsFooterProps = function () {\n    var columns = this.state.adjustedColumns;\n    var _a = this.props,\n        viewport = _a.viewport,\n        checkboxVisibility = _a.checkboxVisibility,\n        indentWidth = _a.indentWidth,\n        _b = _a.cellStyleProps,\n        cellStyleProps = _b === void 0 ? DEFAULT_CELL_STYLE_PROPS : _b,\n        _c = _a.selectionMode,\n        selectionMode = _c === void 0 ? this._selection.mode : _c;\n    return {\n      columns: columns,\n      groupNestingDepth: this._getGroupNestingDepth(),\n      selection: this._selection,\n      selectionMode: selectionMode,\n      viewport: viewport,\n      checkboxVisibility: checkboxVisibility,\n      indentWidth: indentWidth,\n      cellStyleProps: cellStyleProps\n    };\n  };\n\n  DetailsListBase.prototype._getColumnReorderProps = function () {\n    var columnReorderOptions = this.props.columnReorderOptions;\n\n    if (columnReorderOptions) {\n      return tslib_1.__assign({}, columnReorderOptions, {\n        onColumnDragEnd: this._onColumnDragEnd\n      });\n    }\n  };\n\n  DetailsListBase.prototype._getGroupProps = function (detailsGroupProps) {\n    var _this = this;\n\n    var onRenderDetailsGroupFooter = detailsGroupProps.onRenderFooter,\n        onRenderDetailsGroupHeader = detailsGroupProps.onRenderHeader;\n    var columns = this.state.adjustedColumns;\n    var _a = this.props,\n        _b = _a.selectionMode,\n        selectionMode = _b === void 0 ? this._selection.mode : _b,\n        viewport = _a.viewport,\n        _c = _a.cellStyleProps,\n        cellStyleProps = _c === void 0 ? DEFAULT_CELL_STYLE_PROPS : _c,\n        checkboxVisibility = _a.checkboxVisibility,\n        indentWidth = _a.indentWidth;\n\n    var groupNestingDepth = this._getGroupNestingDepth();\n\n    var onRenderFooter = onRenderDetailsGroupFooter ? function (props, defaultRender) {\n      return onRenderDetailsGroupFooter(tslib_1.__assign({}, props, {\n        columns: columns,\n        groupNestingDepth: groupNestingDepth,\n        indentWidth: indentWidth,\n        selection: _this._selection,\n        selectionMode: selectionMode,\n        viewport: viewport,\n        checkboxVisibility: checkboxVisibility,\n        cellStyleProps: cellStyleProps\n      }), defaultRender);\n    } : undefined;\n    var onRenderHeader = onRenderDetailsGroupHeader ? function (props, defaultRender) {\n      return onRenderDetailsGroupHeader(tslib_1.__assign({}, props, {\n        columns: columns,\n        groupNestingDepth: groupNestingDepth,\n        indentWidth: indentWidth,\n        selection: _this._selection,\n        selectionMode: selectionMode,\n        viewport: viewport,\n        checkboxVisibility: checkboxVisibility,\n        cellStyleProps: cellStyleProps\n      }), defaultRender);\n    } : undefined;\n    return tslib_1.__assign({}, detailsGroupProps, {\n      onRenderFooter: onRenderFooter,\n      onRenderHeader: onRenderHeader\n    });\n  };\n\n  DetailsListBase.defaultProps = {\n    layoutMode: DetailsListLayoutMode.justified,\n    selectionMode: SelectionMode.multiple,\n    constrainMode: ConstrainMode.horizontalConstrained,\n    checkboxVisibility: CheckboxVisibility.onHover,\n    isHeaderVisible: true,\n    enableShimmer: false,\n    compact: false\n  };\n  DetailsListBase = tslib_1.__decorate([withViewport], DetailsListBase);\n  return DetailsListBase;\n}(BaseComponent);\n\nexport { DetailsListBase };\nexport function buildColumns(items, canResizeColumns, onColumnClick, sortedColumnKey, isSortedDescending, groupedColumnKey, isMultiline) {\n  var columns = [];\n\n  if (items && items.length) {\n    var firstItem = items[0];\n\n    for (var propName in firstItem) {\n      if (firstItem.hasOwnProperty(propName)) {\n        columns.push({\n          key: propName,\n          name: propName,\n          fieldName: propName,\n          minWidth: MIN_COLUMN_WIDTH,\n          maxWidth: 300,\n          isCollapsable: !!columns.length,\n          isCollapsible: !!columns.length,\n          isMultiline: isMultiline === undefined ? false : isMultiline,\n          isSorted: sortedColumnKey === propName,\n          isSortedDescending: !!isSortedDescending,\n          isRowHeader: false,\n          columnActionsMode: ColumnActionsMode.clickable,\n          isResizable: canResizeColumns,\n          onColumnClick: onColumnClick,\n          isGrouped: groupedColumnKey === propName\n        });\n      }\n    }\n  }\n\n  return columns;\n}\n\nfunction isRightArrow(event) {\n  return event.which === getRTLSafeKeyCode(KeyCodes.right);\n}\n\nfunction getPaddedWidth(column, isFirst, props) {\n  var _a = props.cellStyleProps,\n      cellStyleProps = _a === void 0 ? DEFAULT_CELL_STYLE_PROPS : _a;\n  return column.calculatedWidth + cellStyleProps.cellLeftPadding + cellStyleProps.cellRightPadding + (column.isPadded ? cellStyleProps.cellExtraRightPadding : 0);\n}","map":null,"metadata":{},"sourceType":"module"}