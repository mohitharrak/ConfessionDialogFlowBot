{"ast":null,"code":"import { SELECTION_CHANGE, SelectionMode } from './interfaces';\nimport { EventGroup } from '../../Utilities';\n\nvar Selection =\n/** @class */\nfunction () {\n  function Selection(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var onSelectionChanged = options.onSelectionChanged,\n        getKey = options.getKey,\n        _a = options.canSelectItem,\n        canSelectItem = _a === void 0 ? function (item) {\n      return true;\n    } : _a,\n        _b = options.selectionMode,\n        selectionMode = _b === void 0 ? SelectionMode.multiple : _b;\n    this.mode = selectionMode;\n    this._getKey = getKey || defaultGetKey;\n    this._changeEventSuppressionCount = 0;\n    this._exemptedCount = 0;\n    this._anchoredIndex = 0;\n    this._unselectableCount = 0;\n    this._onSelectionChanged = onSelectionChanged;\n    this._canSelectItem = canSelectItem;\n    this._isModal = false;\n    this.setItems([], true);\n  }\n\n  Selection.prototype.canSelectItem = function (item, index) {\n    if (typeof index === 'number' && index < 0) {\n      return false;\n    }\n\n    return this._canSelectItem(item, index);\n  };\n\n  Selection.prototype.getKey = function (item, index) {\n    var key = this._getKey(item, index);\n\n    return typeof key === 'number' || key ? \"\" + key : '';\n  };\n\n  Selection.prototype.setChangeEvents = function (isEnabled, suppressChange) {\n    this._changeEventSuppressionCount += isEnabled ? -1 : 1;\n\n    if (this._changeEventSuppressionCount === 0 && this._hasChanged) {\n      this._hasChanged = false;\n\n      if (!suppressChange) {\n        this._change();\n      }\n    }\n  };\n\n  Selection.prototype.isModal = function () {\n    return this._isModal;\n  };\n\n  Selection.prototype.setModal = function (isModal) {\n    if (this._isModal !== isModal) {\n      this.setChangeEvents(false);\n      this._isModal = isModal;\n\n      if (!isModal) {\n        this.setAllSelected(false);\n      }\n\n      this._change();\n\n      this.setChangeEvents(true);\n    }\n  };\n  /**\r\n   * Selection needs the items, call this method to set them. If the set\r\n   * of items is the same, this will re-evaluate selection and index maps.\r\n   * Otherwise, shouldClear should be set to true, so that selection is\r\n   * cleared.\r\n   */\n\n\n  Selection.prototype.setItems = function (items, shouldClear) {\n    if (shouldClear === void 0) {\n      shouldClear = true;\n    }\n\n    var newKeyToIndexMap = {};\n    var newUnselectableIndices = {};\n    var hasSelectionChanged = false;\n    this.setChangeEvents(false); // Reset the unselectable count.\n\n    this._unselectableCount = 0; // Build lookup table for quick selection evaluation.\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (item) {\n        var key = this.getKey(item, i);\n\n        if (key) {\n          newKeyToIndexMap[key] = i;\n        }\n      }\n\n      newUnselectableIndices[i] = item && !this.canSelectItem(item);\n\n      if (newUnselectableIndices[i]) {\n        this._unselectableCount++;\n      }\n    }\n\n    if (shouldClear || items.length === 0) {\n      this.setAllSelected(false);\n    } // Check the exemption list for discrepencies.\n\n\n    var newExemptedIndicies = {};\n    var newExemptedCount = 0;\n\n    for (var indexProperty in this._exemptedIndices) {\n      if (this._exemptedIndices.hasOwnProperty(indexProperty)) {\n        var index = Number(indexProperty);\n        var item = this._items[index];\n        var exemptKey = item ? this.getKey(item, Number(index)) : undefined;\n        var newIndex = exemptKey ? newKeyToIndexMap[exemptKey] : index;\n\n        if (newIndex === undefined) {\n          // The item has likely been replaced or removed.\n          hasSelectionChanged = true;\n        } else {\n          // We know the new index of the item. update the existing exemption table.\n          newExemptedIndicies[newIndex] = true;\n          newExemptedCount++;\n          hasSelectionChanged = hasSelectionChanged || newIndex !== index;\n        }\n      }\n    }\n\n    if (this._items && this._exemptedCount === 0 && items.length !== this._items.length && this._isAllSelected) {\n      // If everything was selected but the number of items has changed, selection has changed.\n      hasSelectionChanged = true;\n    }\n\n    this._exemptedIndices = newExemptedIndicies;\n    this._exemptedCount = newExemptedCount;\n    this._keyToIndexMap = newKeyToIndexMap;\n    this._unselectableIndices = newUnselectableIndices;\n    this._items = items;\n    this._selectedItems = null;\n\n    if (hasSelectionChanged) {\n      this._updateCount();\n\n      this._change();\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.getItems = function () {\n    return this._items;\n  };\n\n  Selection.prototype.getSelection = function () {\n    if (!this._selectedItems) {\n      this._selectedItems = [];\n      var items = this._items;\n\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedItems.push(items[i]);\n          }\n        }\n      }\n    }\n\n    return this._selectedItems;\n  };\n\n  Selection.prototype.getSelectedCount = function () {\n    return this._isAllSelected ? this._items.length - this._exemptedCount - this._unselectableCount : this._exemptedCount;\n  };\n\n  Selection.prototype.getSelectedIndices = function () {\n    if (!this._selectedIndices) {\n      this._selectedIndices = [];\n      var items = this._items;\n\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (this.isIndexSelected(i)) {\n            this._selectedIndices.push(i);\n          }\n        }\n      }\n    }\n\n    return this._selectedIndices;\n  };\n\n  Selection.prototype.isRangeSelected = function (fromIndex, count) {\n    if (count === 0) {\n      return false;\n    }\n\n    var endIndex = fromIndex + count;\n\n    for (var i = fromIndex; i < endIndex; i++) {\n      if (!this.isIndexSelected(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.isAllSelected = function () {\n    var selectableCount = this._items.length - this._unselectableCount; // In single mode, we can only have a max of 1 item.\n\n    if (this.mode === SelectionMode.single) {\n      selectableCount = Math.min(selectableCount, 1);\n    }\n\n    return this.count > 0 && this._isAllSelected && this._exemptedCount === 0 || !this._isAllSelected && this._exemptedCount === selectableCount && selectableCount > 0;\n  };\n\n  Selection.prototype.isKeySelected = function (key) {\n    var index = this._keyToIndexMap[key];\n    return this.isIndexSelected(index);\n  };\n\n  Selection.prototype.isIndexSelected = function (index) {\n    return !!(this.count > 0 && this._isAllSelected && !this._exemptedIndices[index] && !this._unselectableIndices[index] || !this._isAllSelected && this._exemptedIndices[index]);\n  };\n\n  Selection.prototype.setAllSelected = function (isAllSelected) {\n    if (isAllSelected && this.mode !== SelectionMode.multiple) {\n      return;\n    }\n\n    var selectableCount = this._items ? this._items.length - this._unselectableCount : 0;\n    this.setChangeEvents(false);\n\n    if (selectableCount > 0 && (this._exemptedCount > 0 || isAllSelected !== this._isAllSelected)) {\n      this._exemptedIndices = {};\n\n      if (isAllSelected !== this._isAllSelected || this._exemptedCount > 0) {\n        this._exemptedCount = 0;\n        this._isAllSelected = isAllSelected;\n\n        this._change();\n      }\n\n      this._updateCount();\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.setKeySelected = function (key, isSelected, shouldAnchor) {\n    var index = this._keyToIndexMap[key];\n\n    if (index >= 0) {\n      this.setIndexSelected(index, isSelected, shouldAnchor);\n    }\n  };\n\n  Selection.prototype.setIndexSelected = function (index, isSelected, shouldAnchor) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    } // Clamp the index.\n\n\n    index = Math.min(Math.max(0, index), this._items.length - 1); // No-op on out of bounds selections.\n\n    if (index < 0 || index >= this._items.length) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n    var isExempt = this._exemptedIndices[index];\n    var canSelect = !this._unselectableIndices[index];\n\n    if (canSelect) {\n      if (isSelected && this.mode === SelectionMode.single) {\n        // If this is single-select, the previous selection should be removed.\n        this.setAllSelected(false);\n      } // Determine if we need to remove the exemption.\n\n\n      if (isExempt && (isSelected && this._isAllSelected || !isSelected && !this._isAllSelected)) {\n        delete this._exemptedIndices[index];\n        this._exemptedCount--;\n      } // Determine if we need to add the exemption.\n\n\n      if (!isExempt && (isSelected && !this._isAllSelected || !isSelected && this._isAllSelected)) {\n        this._exemptedIndices[index] = true;\n        this._exemptedCount++;\n      }\n\n      if (shouldAnchor) {\n        this._anchoredIndex = index;\n      }\n    }\n\n    this._updateCount();\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.selectToKey = function (key, clearSelection) {\n    this.selectToIndex(this._keyToIndexMap[key], clearSelection);\n  };\n\n  Selection.prototype.selectToIndex = function (index, clearSelection) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    if (this.mode === SelectionMode.single) {\n      this.setIndexSelected(index, true, true);\n      return;\n    }\n\n    var anchorIndex = this._anchoredIndex || 0;\n    var startIndex = Math.min(index, anchorIndex);\n    var endIndex = Math.max(index, anchorIndex);\n    this.setChangeEvents(false);\n\n    if (clearSelection) {\n      this.setAllSelected(false);\n    }\n\n    for (; startIndex <= endIndex; startIndex++) {\n      this.setIndexSelected(startIndex, true, false);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype.toggleAllSelected = function () {\n    this.setAllSelected(!this.isAllSelected());\n  };\n\n  Selection.prototype.toggleKeySelected = function (key) {\n    this.setKeySelected(key, !this.isKeySelected(key), true);\n  };\n\n  Selection.prototype.toggleIndexSelected = function (index) {\n    this.setIndexSelected(index, !this.isIndexSelected(index), true);\n  };\n\n  Selection.prototype.toggleRangeSelected = function (fromIndex, count) {\n    if (this.mode === SelectionMode.none) {\n      return;\n    }\n\n    var isRangeSelected = this.isRangeSelected(fromIndex, count);\n    var endIndex = fromIndex + count;\n\n    if (this.mode === SelectionMode.single && count > 1) {\n      return;\n    }\n\n    this.setChangeEvents(false);\n\n    for (var i = fromIndex; i < endIndex; i++) {\n      this.setIndexSelected(i, !isRangeSelected, false);\n    }\n\n    this.setChangeEvents(true);\n  };\n\n  Selection.prototype._updateCount = function () {\n    var count = this.getSelectedCount();\n\n    if (count !== this.count) {\n      this.count = count;\n\n      this._change();\n    }\n\n    if (!this.count) {\n      this.setModal(false);\n    }\n  };\n\n  Selection.prototype._change = function () {\n    if (this._changeEventSuppressionCount === 0) {\n      this._selectedItems = null;\n      this._selectedIndices = undefined;\n      EventGroup.raise(this, SELECTION_CHANGE);\n\n      if (this._onSelectionChanged) {\n        this._onSelectionChanged();\n      }\n    } else {\n      this._hasChanged = true;\n    }\n  };\n\n  return Selection;\n}();\n\nexport { Selection };\n\nfunction defaultGetKey(item, index) {\n  return item && item.key ? item.key : \"\" + index;\n}","map":null,"metadata":{},"sourceType":"module"}