{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { concatStyleSets } from '@uifabric/styling';\nimport { Customizations, CustomizerContext } from '@uifabric/utilities';\nimport { createFactory } from './slots';\nimport { assign } from './utilities';\n/**\r\n * Assembles a higher order component based on the following: styles, theme, view, and state.\r\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\r\n * in how components use and apply styling and theming.\r\n *\r\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\r\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\r\n * and styled before finally being passed to view.\r\n *\r\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call the view prop.\r\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\r\n * State component is optional. If state is not provided, created component is essentially a functional stateless component.\r\n *\r\n * * TComponentProps: A styleable props interface for the created component.\r\n * * TTokens: The type for tokens props.\r\n * * TStyleSet: The type for styles properties.\r\n * * TViewProps: The props specific to the view, including processed properties outputted by optional state component. If state\r\n * component is not provided, TComponentProps is the same as TViewProps.\r\n * * TStatics: Static type for statics applied to created component object.\r\n *\r\n * @param {IComponent} component Component options. See IComponent for more detail.\r\n */\n\nexport function createComponent(component) {\n  var _a = component.factoryOptions,\n      factoryOptions = _a === void 0 ? {} : _a;\n  var defaultProp = factoryOptions.defaultProp;\n\n  var result = function result(componentProps) {\n    return (// TODO: createComponent is also affected by https://github.com/OfficeDev/office-ui-fabric-react/issues/6603\n      React.createElement(CustomizerContext.Consumer, null, function (context) {\n        // TODO: this next line is basically saying 'theme' prop will ALWAYS be available from getCustomizations\n        //        via ICustomizationProps cast. Is there mechanism that guarantees theme and other request fields will be defined?\n        //        is there a static init that guarantees theme will be provided?\n        //        what happens if createTheme/loadTheme is not called?\n        //        if so, convey through getCustomizations typing keying off fields. can we convey this\n        //          all the way from Customizations with something like { { K in fields }: object}? hmm\n        //        if not, how does existing \"theme!\" styles code work without risk of failing (assuming it doesn't fail)?\n        // For now cast return value as if theme is always available.\n        var settings = _getCustomizations(component.displayName, context, component.fields);\n\n        var renderView = function renderView(viewProps) {\n          // The approach here is to allow state components to provide only the props they care about, automatically\n          //    merging user props and state props together. This ensures all props are passed properly to view,\n          //    including children and styles.\n          // TODO: for full 'fields' support, 'rest' props from customizations need to pass onto view.\n          //        however, customized props like theme will break snapshots. how is styled not showing theme output in snapshots?\n          var mergedProps = viewProps ? tslib_1.__assign({}, componentProps, viewProps) : componentProps;\n          var theme = mergedProps.theme || settings.theme;\n\n          var tokens = _resolveTokens(mergedProps, theme, component.tokens, settings.tokens, mergedProps.tokens);\n\n          var styles = _resolveStyles(mergedProps, theme, tokens, component.styles, settings.styles, mergedProps.styles);\n\n          var viewComponentProps = tslib_1.__assign({}, mergedProps, {\n            _defaultStyles: styles\n          });\n\n          return component.view(viewComponentProps);\n        };\n\n        return component.state ? React.createElement(component.state, tslib_1.__assign({}, componentProps, {\n          renderView: renderView\n        })) : renderView();\n      })\n    );\n  };\n\n  result.displayName = component.displayName; // If a shorthand prop is defined, create a factory for the component.\n  // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n  //       Need to weigh creating default factories on component creation vs. memozing them on use in slots.tsx.\n\n  if (defaultProp) {\n    result.create = createFactory(result, {\n      defaultProp: defaultProp\n    });\n  }\n\n  assign(result, component.statics); // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n\n  return result;\n}\n/**\r\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\r\n */\n\nfunction _resolveStyles(props, theme, tokens) {\n  var allStyles = [];\n\n  for (var _i = 3; _i < arguments.length; _i++) {\n    allStyles[_i - 3] = arguments[_i];\n  }\n\n  return concatStyleSets.apply(void 0, allStyles.map(function (styles) {\n    return typeof styles === 'function' ? styles(props, theme, tokens) : styles;\n  }));\n}\n/**\r\n * Resolve all tokens functions with props flatten results along with all tokens objects.\r\n */\n\n\nfunction _resolveTokens(props, theme) {\n  var allTokens = [];\n\n  for (var _i = 2; _i < arguments.length; _i++) {\n    allTokens[_i - 2] = arguments[_i];\n  }\n\n  var tokens = {};\n\n  for (var _a = 0, allTokens_1 = allTokens; _a < allTokens_1.length; _a++) {\n    var currentTokens = allTokens_1[_a];\n\n    if (currentTokens) {\n      currentTokens = typeof currentTokens === 'function' ? currentTokens(props, theme) : currentTokens;\n\n      if (Array.isArray(currentTokens)) {\n        currentTokens = _resolveTokens.apply(void 0, [props, theme].concat(currentTokens));\n      }\n\n      assign.apply(void 0, [tokens].concat(currentTokens));\n    }\n  }\n\n  return tokens;\n}\n/**\r\n * Helper function for calling Customizations.getSettings falling back to default fields.\r\n *\r\n * @param displayName Displayable name for component.\r\n * @param context React context passed to component containing contextual settings.\r\n * @param fields Optional list of properties to grab from global store and context.\r\n */\n\n\nfunction _getCustomizations(displayName, context, fields) {\n  // TODO: do we want field props? should fields be part of IComponent and used here?\n  // TODO: should we centrally define DefaultFields? (not exported from styling)\n  // TOOD: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n  var DefaultFields = ['theme', 'styles', 'tokens'];\n  return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}","map":null,"metadata":{},"sourceType":"module"}