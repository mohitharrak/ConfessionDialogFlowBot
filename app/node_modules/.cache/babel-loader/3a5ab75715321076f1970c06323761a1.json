{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseComponent, classNamesFunction, divProperties, findIndex, getDocument, getFirstFocusable, getId, getLastFocusable, getNativeProps, isIOS, isMac, KeyCodes, mergeAriaAttributeValues } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { CommandButton } from '../../Button';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { DropdownMenuItemType } from './Dropdown.types';\nimport { DropdownSizePosCache } from './utilities/DropdownSizePosCache';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Icon } from '../../Icon';\nimport { Label } from '../../Label';\nimport { KeytipData } from '../../KeytipData';\nimport { Panel } from '../../Panel';\nimport { ResponsiveMode, withResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { SelectableOptionMenuItemType } from '../../utilities/selectableOption/SelectableOption.types';\nvar getClassNames = classNamesFunction();\n\nvar DropdownBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DropdownBase, _super);\n\n  function DropdownBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._host = React.createRef();\n    _this._focusZone = React.createRef();\n    _this._dropDown = React.createRef();\n    _this._scrollIdleDelay = 250\n    /* ms */\n    ;\n    _this._sizePosCache = new DropdownSizePosCache();\n    /** Render text in dropdown input */\n\n    _this._onRenderTitle = function (item) {\n      var _a = _this.props.multiSelectDelimiter,\n          multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n      var displayTxt = item.map(function (i) {\n        return i.text;\n      }).join(multiSelectDelimiter);\n      return React.createElement(\"span\", null, displayTxt);\n    };\n    /** Render placeholder text in dropdown input */\n\n\n    _this._onRenderPlaceholder = function (props) {\n      if (!_this._placeholder) {\n        return null;\n      }\n\n      return React.createElement(\"span\", null, _this._placeholder);\n    };\n    /** Render Callout or Panel container and pass in list */\n\n\n    _this._onRenderContainer = function (props) {\n      var _a = _this.props,\n          responsiveMode = _a.responsiveMode,\n          calloutProps = _a.calloutProps,\n          panelProps = _a.panelProps,\n          dropdownWidth = _a.dropdownWidth;\n      var isSmall = responsiveMode <= ResponsiveMode.medium;\n      var panelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.panel : undefined;\n      return isSmall ? React.createElement(Panel, tslib_1.__assign({\n        isOpen: true,\n        isLightDismiss: true,\n        onDismissed: _this._onDismiss,\n        hasCloseButton: false,\n        styles: panelStyles\n      }, panelProps), _this._renderFocusableList(props)) : React.createElement(Callout, tslib_1.__assign({\n        isBeakVisible: false,\n        gapSpace: 0,\n        doNotLayer: false,\n        directionalHintFixed: false,\n        directionalHint: DirectionalHint.bottomLeftEdge\n      }, calloutProps, {\n        className: _this._classNames.callout,\n        target: _this._dropDown.current,\n        onDismiss: _this._onDismiss,\n        onScroll: _this._onScroll,\n        onPositioned: _this._onPositioned,\n        calloutWidth: dropdownWidth || (_this._dropDown.current ? _this._dropDown.current.clientWidth : 0)\n      }), _this._renderFocusableList(props));\n    };\n    /** Render Caret Down Icon */\n\n\n    _this._onRenderCaretDown = function (props) {\n      return React.createElement(Icon, {\n        className: _this._classNames.caretDown,\n        iconName: \"ChevronDown\"\n      });\n    };\n    /** Render List of items */\n\n\n    _this._onRenderList = function (props) {\n      var _a = _this.props.onRenderItem,\n          onRenderItem = _a === void 0 ? _this._onRenderItem : _a;\n      return React.createElement(React.Fragment, null, _this.props.options.map(function (item, index) {\n        return onRenderItem(tslib_1.__assign({}, item, {\n          index: index\n        }), _this._onRenderItem);\n      }));\n    };\n\n    _this._onRenderItem = function (item) {\n      switch (item.itemType) {\n        case SelectableOptionMenuItemType.Divider:\n          return _this._renderSeparator(item);\n\n        case SelectableOptionMenuItemType.Header:\n          return _this._renderHeader(item);\n\n        default:\n          return _this._renderOption(item);\n      }\n    };\n\n    _this._renderOption = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOption : _a;\n      var _b = _this.state.selectedIndices,\n          selectedIndices = _b === void 0 ? [] : _b;\n      var id = _this._id;\n      var isItemSelected = item.index !== undefined && selectedIndices ? selectedIndices.indexOf(item.index) > -1 : false; // select the right className based on the combination of selected/disabled\n\n      var itemClassName = isItemSelected && item.disabled === true // predicate: both selected and disabled\n      ? _this._classNames.dropdownItemSelectedAndDisabled : isItemSelected // predicate: selected only\n      ? _this._classNames.dropdownItemSelected : item.disabled === true // predicate: disabled only\n      ? _this._classNames.dropdownItemDisabled : _this._classNames.dropdownItem;\n      return !_this.props.multiSelect ? React.createElement(CommandButton, {\n        id: id + '-list' + item.index,\n        key: item.key,\n        \"data-index\": item.index,\n        \"data-is-focusable\": !item.disabled,\n        disabled: item.disabled,\n        className: itemClassName,\n        onClick: _this._onItemClick(item),\n        onMouseEnter: _this._onItemMouseEnter.bind(_this, item),\n        onMouseLeave: _this._onMouseItemLeave.bind(_this, item),\n        onMouseMove: _this._onItemMouseMove.bind(_this, item),\n        role: \"option\",\n        \"aria-selected\": isItemSelected ? 'true' : 'false',\n        ariaLabel: item.ariaLabel,\n        title: item.title ? item.title : item.text\n      }, onRenderOption(item, _this._onRenderOption)) : React.createElement(Checkbox, {\n        id: id + '-list' + item.index,\n        key: item.key,\n        \"data-index\": item.index,\n        \"data-is-focusable\": !item.disabled,\n        disabled: item.disabled,\n        onChange: _this._onItemClick(item),\n        inputProps: {\n          onMouseEnter: _this._onItemMouseEnter.bind(_this, item),\n          onMouseLeave: _this._onMouseItemLeave.bind(_this, item),\n          onMouseMove: _this._onItemMouseMove.bind(_this, item)\n        },\n        label: item.text,\n        title: item.title ? item.title : item.text,\n        onRenderLabel: _this._onRenderLabel.bind(_this, item),\n        className: itemClassName,\n        role: \"option\",\n        \"aria-selected\": isItemSelected ? 'true' : 'false',\n        checked: isItemSelected\n      });\n    };\n    /** Render content of item (i.e. text/icon inside of button) */\n\n\n    _this._onRenderOption = function (item) {\n      return React.createElement(\"span\", {\n        className: _this._classNames.dropdownOptionText\n      }, item.text);\n    };\n    /** Render custom label for drop down item */\n\n\n    _this._onRenderLabel = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOption : _a;\n      return onRenderOption(item, _this._onRenderOption);\n    };\n\n    _this._onPositioned = function (positions) {\n      if (_this._focusZone.current) {\n        // Focusing an element can trigger a reflow. Making this wait until there is an animation\n        // frame can improve perf significantly.\n        _this._async.requestAnimationFrame(function () {\n          var selectedIndices = _this.state.selectedIndices;\n\n          if (selectedIndices && selectedIndices[0] && !_this.props.options[selectedIndices[0]].disabled) {\n            var element = getDocument().querySelector(\"#\" + _this._id + \"-list\" + selectedIndices[0]);\n\n            _this._focusZone.current.focusElement(element);\n          } else {\n            _this._focusZone.current.focus();\n          }\n        });\n      }\n\n      if (!_this.state.calloutRenderEdge || _this.state.calloutRenderEdge !== positions.targetEdge) {\n        _this.setState({\n          calloutRenderEdge: positions.targetEdge\n        });\n      }\n    };\n\n    _this._onItemClick = function (item) {\n      return function (event) {\n        if (!item.disabled) {\n          _this.setSelectedIndex(event, item.index);\n\n          if (!_this.props.multiSelect) {\n            // only close the callout when it's in single-select mode\n            _this.setState({\n              isOpen: false\n            });\n          }\n        }\n      };\n    };\n    /**\r\n     * Scroll handler for the callout to make sure the mouse events\r\n     * for updating focus are not interacting during scroll\r\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        _this._async.clearTimeout(_this._scrollIdleTimeoutId);\n\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = _this._async.setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, _this._scrollIdleDelay);\n    };\n\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n      /**\r\n       * IE11 focus() method forces parents to scroll to top of element.\r\n       * Edge and IE expose a setActive() function for focusable divs that\r\n       * sets the page focus but does not scroll the parent element.\r\n       */\n\n\n      if (_this._host.current) {\n        if (_this._host.current.setActive) {\n          try {\n            _this._host.current.setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          _this._host.current.focus();\n        }\n      }\n    };\n\n    _this._onDismiss = function () {\n      _this.setState({\n        isOpen: false\n      });\n\n      if (_this._dropDown.current) {\n        _this._dropDown.current.focus();\n      }\n    };\n\n    _this._onDropdownBlur = function (ev) {\n      // If Dropdown disabled do not proceed with this logic.\n      var disabled = _this._isDisabled();\n\n      if (disabled) {\n        return;\n      } // hasFocus tracks whether the root element has focus so always update the state.\n\n\n      _this.setState({\n        hasFocus: false\n      });\n\n      if (_this.state.isOpen) {\n        // Do not onBlur when the callout is opened\n        return;\n      }\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onDropdownKeyDown = function (ev) {\n      // If Dropdown disabled do not process any keyboard events.\n      var disabled = _this._isDisabled();\n\n      if (disabled) {\n        return;\n      } // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n\n\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n\n      var newIndex;\n      var selectedIndex = _this.state.selectedIndices.length ? _this.state.selectedIndices[0] : -1;\n      var containsExpandCollapseModifier = ev.altKey || ev.metaKey;\n      var isOpen = _this.state.isOpen;\n\n      switch (ev.which) {\n        case KeyCodes.enter:\n          _this.setState({\n            isOpen: !isOpen\n          });\n\n          break;\n\n        case KeyCodes.escape:\n          if (!isOpen) {\n            return;\n          }\n\n          _this.setState({\n            isOpen: false\n          });\n\n          break;\n\n        case KeyCodes.up:\n          if (containsExpandCollapseModifier) {\n            if (isOpen) {\n              _this.setState({\n                isOpen: false\n              });\n\n              break;\n            }\n\n            return;\n          }\n\n          if (_this.props.multiSelect) {\n            _this.setState({\n              isOpen: true\n            });\n          } else if (!_this._isDisabled()) {\n            newIndex = _this._moveIndex(ev, -1, selectedIndex - 1, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.down:\n          if (containsExpandCollapseModifier) {\n            ev.stopPropagation();\n            ev.preventDefault();\n          }\n\n          if (containsExpandCollapseModifier && !isOpen || _this.props.multiSelect) {\n            _this.setState({\n              isOpen: true\n            });\n          } else if (!_this._isDisabled()) {\n            newIndex = _this._moveIndex(ev, 1, selectedIndex + 1, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.home:\n          if (!_this.props.multiSelect) {\n            newIndex = _this._moveIndex(ev, 1, 0, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.end:\n          if (!_this.props.multiSelect) {\n            newIndex = _this._moveIndex(ev, -1, _this.props.options.length - 1, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.space:\n          // event handled in _onDropdownKeyUp\n          break;\n\n        default:\n          return;\n      }\n\n      if (newIndex !== selectedIndex) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    };\n\n    _this._onDropdownKeyUp = function (ev) {\n      // If Dropdown disabled do not process any keyboard events.\n      var disabled = _this._isDisabled();\n\n      if (disabled) {\n        return;\n      }\n\n      var shouldHandleKey = _this._shouldHandleKeyUp(ev);\n\n      var isOpen = _this.state.isOpen;\n\n      if (_this.props.onKeyUp) {\n        _this.props.onKeyUp(ev);\n\n        if (ev.preventDefault) {\n          return;\n        }\n      }\n\n      switch (ev.which) {\n        case KeyCodes.space:\n          _this.setState({\n            isOpen: !isOpen\n          });\n\n          break;\n\n        default:\n          if (shouldHandleKey && isOpen) {\n            _this.setState({\n              isOpen: false\n            });\n          }\n\n          return;\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onZoneKeyDown = function (ev) {\n      var elementToFocus; // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n      var containsExpandCollapseModifier = ev.altKey || ev.metaKey;\n\n      switch (ev.which) {\n        case KeyCodes.up:\n          if (containsExpandCollapseModifier) {\n            _this.setState({\n              isOpen: false\n            });\n          } else {\n            if (_this._host.current) {\n              elementToFocus = getLastFocusable(_this._host.current, _this._host.current.lastChild, true);\n            }\n          }\n\n          break;\n        // All directional keystrokes should be canceled when the zone is rendered.\n        // This avoids the body scroll from reacting and thus dismissing the dropdown.\n\n        case KeyCodes.home:\n        case KeyCodes.end:\n        case KeyCodes.pageUp:\n        case KeyCodes.pageDown:\n          break;\n\n        case KeyCodes.down:\n          if (!containsExpandCollapseModifier && _this._host.current) {\n            elementToFocus = getFirstFocusable(_this._host.current, _this._host.current.firstChild, true);\n          }\n\n          break;\n\n        case KeyCodes.escape:\n          _this.setState({\n            isOpen: false\n          });\n\n          break;\n\n        case KeyCodes.tab:\n          _this.setState({\n            isOpen: false\n          });\n\n          return;\n\n        default:\n          return;\n      }\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onZoneKeyUp = function (ev) {\n      var shouldHandleKey = _this._shouldHandleKeyUp(ev);\n\n      if (shouldHandleKey && _this.state.isOpen) {\n        _this.setState({\n          isOpen: false\n        });\n\n        ev.preventDefault();\n      }\n    };\n\n    _this._onDropdownClick = function (ev) {\n      if (_this.props.onClick) {\n        _this.props.onClick(ev);\n\n        if (ev.preventDefault) {\n          return;\n        }\n      }\n\n      var isOpen = _this.state.isOpen;\n\n      var disabled = _this._isDisabled();\n\n      if (!disabled) {\n        _this.setState({\n          isOpen: !isOpen\n        });\n      }\n    };\n\n    _this._onFocus = function (ev) {\n      var _a = _this.state,\n          isOpen = _a.isOpen,\n          selectedIndices = _a.selectedIndices;\n      var multiSelect = _this.props.multiSelect;\n\n      var disabled = _this._isDisabled();\n\n      if (!disabled) {\n        if (!isOpen && selectedIndices.length === 0 && !multiSelect) {\n          // Per aria\n          _this._moveIndex(ev, 1, 0, -1);\n        }\n\n        if (_this.props.onFocus) {\n          _this.props.onFocus(ev);\n        }\n\n        _this.setState({\n          hasFocus: true\n        });\n      }\n    };\n    /**\r\n     * Because the isDisabled prop is deprecated, we have had to repeat this logic all over the place.\r\n     * This helper method avoids all the repetition.\r\n     */\n\n\n    _this._isDisabled = function () {\n      var disabled = _this.props.disabled;\n      var isDisabled = _this.props.isDisabled; // Remove this deprecation workaround at 1.0.0\n\n      if (isDisabled !== undefined) {\n        disabled = isDisabled;\n      }\n\n      return disabled;\n    };\n\n    _this._warnDeprecations({\n      isDisabled: 'disabled',\n      onChanged: 'onChange',\n      placeHolder: 'placeholder'\n    });\n\n    _this._warnMutuallyExclusive({\n      defaultSelectedKey: 'selectedKey',\n      defaultSelectedKeys: 'selectedKeys',\n      selectedKeys: 'selectedKey',\n      multiSelect: 'defaultSelectedKey',\n      selectedKey: 'multiSelect'\n    });\n\n    _this._id = props.id || getId('Dropdown');\n    _this._isScrollIdle = true;\n    var selectedIndices;\n\n    if (_this.props.multiSelect) {\n      var selectedKeys = props.defaultSelectedKeys !== undefined ? props.defaultSelectedKeys : props.selectedKeys;\n      selectedIndices = _this._getSelectedIndexes(props.options, selectedKeys);\n    } else {\n      var selectedKey = props.defaultSelectedKey !== undefined ? props.defaultSelectedKey : props.selectedKey;\n      selectedIndices = _this._getSelectedIndexes(props.options, selectedKey);\n\n      _this._sizePosCache.updateOptions(props.options);\n    }\n\n    _this.state = {\n      isOpen: false,\n      selectedIndices: selectedIndices,\n      hasFocus: false,\n      calloutRenderEdge: undefined\n    };\n    return _this;\n  }\n\n  DropdownBase.prototype.componentWillReceiveProps = function (newProps) {\n    // In controlled component usage where selectedKey is provided, update the selectedIndex\n    // state if the key or options change.\n    var selectedKeyProp; // this does a shallow compare (assumes options are pure), for the purposes of determining whether\n    // defaultSelectedKey/defaultSelectedKeys are respected.\n\n    var didOptionsChange = newProps.options !== this.props.options;\n\n    if (newProps.multiSelect) {\n      if (didOptionsChange && newProps.defaultSelectedKeys !== undefined) {\n        selectedKeyProp = 'defaultSelectedKeys';\n      } else {\n        selectedKeyProp = 'selectedKeys';\n      }\n    } else {\n      if (didOptionsChange && newProps.defaultSelectedKey !== undefined) {\n        selectedKeyProp = 'defaultSelectedKey';\n      } else {\n        selectedKeyProp = 'selectedKey';\n      }\n    }\n\n    if (newProps[selectedKeyProp] !== undefined && (newProps[selectedKeyProp] !== this.props[selectedKeyProp] || didOptionsChange)) {\n      this.setState({\n        selectedIndices: this._getSelectedIndexes(newProps.options, newProps[selectedKeyProp])\n      });\n    }\n\n    if (newProps.options !== this.props.options && // preexisting code assumes purity of the options...\n    !newProps.multiSelect // only relevant in single selection\n    ) {\n        this._sizePosCache.updateOptions(newProps.options);\n      }\n  };\n\n  DropdownBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevState.isOpen === true && this.state.isOpen === false) {\n      this._gotMouseMove = false;\n\n      if (this._dropDown.current) {\n        this._dropDown.current.focus();\n      }\n\n      if (this.props.onDismiss) {\n        this.props.onDismiss();\n      }\n    }\n  };\n\n  DropdownBase.prototype.render = function () {\n    var _this = this;\n\n    var id = this._id;\n    var _a = this.props,\n        className = _a.className,\n        label = _a.label,\n        options = _a.options,\n        ariaLabel = _a.ariaLabel,\n        required = _a.required,\n        errorMessage = _a.errorMessage,\n        multiSelect = _a.multiSelect,\n        keytipProps = _a.keytipProps,\n        propStyles = _a.styles,\n        theme = _a.theme,\n        panelProps = _a.panelProps,\n        calloutProps = _a.calloutProps,\n        _b = _a.onRenderTitle,\n        onRenderTitle = _b === void 0 ? this._onRenderTitle : _b,\n        _c = _a.onRenderContainer,\n        onRenderContainer = _c === void 0 ? this._onRenderContainer : _c,\n        _d = _a.onRenderPlaceHolder,\n        onRenderPlaceHolder = _d === void 0 ? this._onRenderPlaceholder : _d,\n        _e = _a.onRenderCaretDown,\n        onRenderCaretDown = _e === void 0 ? this._onRenderCaretDown : _e;\n    var _f = this.state,\n        isOpen = _f.isOpen,\n        selectedIndices = _f.selectedIndices,\n        hasFocus = _f.hasFocus,\n        calloutRenderEdge = _f.calloutRenderEdge;\n\n    var selectedOptions = this._getAllSelectedOptions(options, selectedIndices);\n\n    var divProps = getNativeProps(this.props, divProperties);\n\n    var disabled = this._isDisabled();\n\n    var optionId = id + '-option';\n    var ariaAttrs = multiSelect || disabled ? {\n      role: undefined,\n      ariaActiveDescendant: undefined,\n      childRole: undefined,\n      ariaSetSize: undefined,\n      ariaPosInSet: undefined,\n      ariaSelected: undefined\n    } : // single select\n    {\n      role: 'listbox',\n      ariaActiveDescendant: isOpen && selectedIndices.length === 1 && selectedIndices[0] >= 0 ? this._id + '-list' + selectedIndices[0] : optionId,\n      childRole: 'option',\n      ariaSetSize: this._sizePosCache.optionSetSize,\n      ariaPosInSet: this._sizePosCache.positionInSet(selectedIndices[0]),\n      ariaSelected: selectedIndices[0] === undefined ? undefined : true\n    };\n    this._classNames = getClassNames(propStyles, {\n      theme: theme,\n      className: className,\n      hasError: Boolean(errorMessage && errorMessage.length > 0),\n      isOpen: isOpen,\n      required: required,\n      disabled: disabled,\n      isRenderingPlaceholder: !selectedOptions.length,\n      panelClassName: !!panelProps ? panelProps.className : undefined,\n      calloutClassName: !!calloutProps ? calloutProps.className : undefined,\n      calloutRenderEdge: calloutRenderEdge\n    });\n    var labelStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.label : undefined;\n    return React.createElement(\"div\", {\n      className: this._classNames.root\n    }, label && React.createElement(Label, {\n      className: this._classNames.label,\n      id: id + '-label',\n      htmlFor: id,\n      required: required,\n      styles: labelStyles\n    }, label), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", tslib_1.__assign({}, keytipAttributes, {\n        \"data-is-focusable\": !disabled,\n        ref: _this._dropDown,\n        id: id,\n        tabIndex: disabled ? -1 : 0,\n        \"aria-expanded\": isOpen ? 'true' : 'false',\n        role: ariaAttrs.role,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": label && !ariaLabel ? id + '-label' : undefined,\n        \"aria-describedby\": mergeAriaAttributeValues(optionId, keytipAttributes['aria-describedby']),\n        \"aria-activedescendant\": isOpen ? ariaAttrs.ariaActiveDescendant : undefined,\n        \"aria-required\": required,\n        \"aria-disabled\": disabled,\n        \"aria-owns\": isOpen ? id + '-list' : undefined\n      }, divProps, {\n        className: _this._classNames.dropdown,\n        onBlur: _this._onDropdownBlur,\n        onKeyDown: _this._onDropdownKeyDown,\n        onKeyUp: _this._onDropdownKeyUp,\n        onClick: _this._onDropdownClick,\n        onFocus: _this._onFocus\n      }), React.createElement(\"span\", {\n        id: optionId,\n        className: _this._classNames.title,\n        \"aria-atomic\": true,\n        role: ariaAttrs.childRole,\n        \"aria-live\": !hasFocus || disabled || multiSelect || isOpen ? 'off' : 'assertive',\n        \"aria-label\": selectedOptions.length ? selectedOptions[0].text : _this._placeholder,\n        \"aria-setsize\": ariaAttrs.ariaSetSize,\n        \"aria-posinset\": ariaAttrs.ariaPosInSet,\n        \"aria-selected\": ariaAttrs.ariaSelected\n      }, // If option is selected render title, otherwise render the placeholder text\n      selectedOptions.length ? onRenderTitle(selectedOptions, _this._onRenderTitle) : onRenderPlaceHolder(_this.props, _this._onRenderPlaceholder)), React.createElement(\"span\", {\n        className: _this._classNames.caretDownWrapper\n      }, onRenderCaretDown(_this.props, _this._onRenderCaretDown)));\n    }), isOpen && onRenderContainer(this.props, this._onRenderContainer), errorMessage && errorMessage.length > 0 && React.createElement(\"div\", {\n      className: this._classNames.errorMessage\n    }, errorMessage));\n  };\n\n  DropdownBase.prototype.focus = function (shouldOpenOnFocus) {\n    if (this._dropDown.current && this._dropDown.current.tabIndex !== -1) {\n      this._dropDown.current.focus();\n\n      if (shouldOpenOnFocus) {\n        this.setState({\n          isOpen: true\n        });\n      }\n    }\n  };\n\n  DropdownBase.prototype.setSelectedIndex = function (event, index) {\n    var _a = this.props,\n        onChange = _a.onChange,\n        onChanged = _a.onChanged,\n        options = _a.options,\n        selectedKey = _a.selectedKey,\n        selectedKeys = _a.selectedKeys,\n        multiSelect = _a.multiSelect,\n        notifyOnReselect = _a.notifyOnReselect;\n    var _b = this.state.selectedIndices,\n        selectedIndices = _b === void 0 ? [] : _b;\n    var checked = selectedIndices ? selectedIndices.indexOf(index) > -1 : false;\n    index = Math.max(0, Math.min(options.length - 1, index));\n\n    if (!multiSelect && !notifyOnReselect && index === selectedIndices[0]) {\n      return;\n    } else if (!multiSelect && selectedKey === undefined) {\n      // Set the selected option if this is an uncontrolled component\n      this.setState({\n        selectedIndices: [index]\n      });\n    } else if (multiSelect && selectedKeys === undefined) {\n      var newIndexes = selectedIndices ? this._copyArray(selectedIndices) : [];\n\n      if (checked) {\n        var position = newIndexes.indexOf(index);\n\n        if (position > -1) {\n          // unchecked the current one\n          newIndexes.splice(position, 1);\n        }\n      } else {\n        // add the new selected index into the existing one\n        newIndexes.push(index);\n      }\n\n      this.setState({\n        selectedIndices: newIndexes\n      });\n    }\n\n    if (onChange) {\n      // for single-select, option passed in will always be selected.\n      // for multi-select, flip the checked value\n      var changedOpt = multiSelect ? tslib_1.__assign({}, options[index], {\n        selected: !checked\n      }) : options[index];\n      onChange(event, changedOpt, index);\n    }\n\n    if (onChanged) {\n      // for single-select, option passed in will always be selected.\n      // for multi-select, flip the checked value\n      var changedOpt = multiSelect ? tslib_1.__assign({}, options[index], {\n        selected: !checked\n      }) : options[index];\n      onChanged(changedOpt, index);\n    }\n  };\n\n  Object.defineProperty(DropdownBase.prototype, \"_placeholder\", {\n    /** Get either props.placeholder (new name) or props.placeHolder (old name) */\n    get: function get() {\n      return this.props.placeholder || this.props.placeHolder;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DropdownBase.prototype._copyArray = function (array) {\n    var newArray = [];\n\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var element = array_1[_i];\n      newArray.push(element);\n    }\n\n    return newArray;\n  };\n  /**\r\n   * Finds the next valid Dropdown option and sets the selected index to it.\r\n   * @param stepValue Value of how many items the function should traverse.  Should be -1 or 1.\r\n   * @param index Index of where the search should start\r\n   * @param selectedIndex The selectedIndex Dropdown's state\r\n   * @returns The next valid dropdown option's index\r\n   */\n\n\n  DropdownBase.prototype._moveIndex = function (event, stepValue, index, selectedIndex) {\n    var options = this.props.options; // Return selectedIndex if nothing has changed or options is empty\n\n    if (selectedIndex === index || options.length === 0) {\n      return selectedIndex;\n    } // Set starting index to 0 if index is < 0\n\n\n    if (index < 0) {\n      index = 0;\n    } // Set starting index to last option index if greater than options.length\n\n\n    if (index >= options.length) {\n      index = options.length - 1;\n    }\n\n    var stepCounter = 0; // If current index is a header or divider, or disabled, increment by step\n\n    while (options[index].itemType === DropdownMenuItemType.Header || options[index].itemType === DropdownMenuItemType.Divider || options[index].disabled) {\n      // If stepCounter exceeds length of options, then return selectedIndex (-1)\n      if (stepCounter >= options.length) {\n        return selectedIndex;\n      } // If index + stepValue is out of bounds, wrap around\n\n\n      if (index + stepValue < 0) {\n        index = options.length;\n      } else if (index + stepValue >= options.length) {\n        index = -1;\n      }\n\n      index = index + stepValue;\n      stepCounter++;\n    }\n\n    this.setSelectedIndex(event, index);\n    return index;\n  };\n  /** Wrap item list in a FocusZone */\n\n\n  DropdownBase.prototype._renderFocusableList = function (props) {\n    var _a = props.onRenderList,\n        onRenderList = _a === void 0 ? this._onRenderList : _a,\n        label = props.label;\n    var id = this._id;\n    return React.createElement(\"div\", {\n      className: this._classNames.dropdownItemsWrapper,\n      onKeyDown: this._onZoneKeyDown,\n      onKeyUp: this._onZoneKeyUp,\n      ref: this._host,\n      tabIndex: 0\n    }, React.createElement(FocusZone, {\n      ref: this._focusZone,\n      direction: FocusZoneDirection.vertical,\n      id: id + '-list',\n      className: this._classNames.dropdownItems,\n      \"aria-labelledby\": label ? id + '-label' : undefined,\n      role: \"listbox\"\n    }, onRenderList(props, this._onRenderList)));\n  };\n\n  DropdownBase.prototype._renderSeparator = function (item) {\n    var index = item.index,\n        key = item.key;\n\n    if (index > 0) {\n      return React.createElement(\"div\", {\n        role: \"separator\",\n        key: key,\n        className: this._classNames.dropdownDivider\n      });\n    }\n\n    return null;\n  };\n\n  DropdownBase.prototype._renderHeader = function (item) {\n    var _a = this.props.onRenderOption,\n        onRenderOption = _a === void 0 ? this._onRenderOption : _a;\n    var key = item.key;\n    return React.createElement(\"div\", {\n      key: key,\n      className: this._classNames.dropdownItemHeader\n    }, onRenderOption(item, this._onRenderOption));\n  };\n\n  DropdownBase.prototype._onItemMouseEnter = function (item, ev) {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    var targetElement = ev.currentTarget;\n    targetElement.focus();\n  };\n\n  DropdownBase.prototype._onItemMouseMove = function (item, ev) {\n    var targetElement = ev.currentTarget;\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || document.activeElement === targetElement) {\n      return;\n    }\n\n    targetElement.focus();\n  };\n\n  DropdownBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /** Get all selected indexes for multi-select mode */\n\n\n  DropdownBase.prototype._getSelectedIndexes = function (options, selectedKey) {\n    if (selectedKey === undefined) {\n      if (this.props.multiSelect) {\n        return this._getAllSelectedIndices(options);\n      }\n\n      var selectedIndex = this._getSelectedIndex(options, null);\n\n      return selectedIndex !== -1 ? [selectedIndex] : [];\n    } else if (!Array.isArray(selectedKey)) {\n      return [this._getSelectedIndex(options, selectedKey)];\n    }\n\n    var selectedIndices = [];\n\n    for (var _i = 0, selectedKey_1 = selectedKey; _i < selectedKey_1.length; _i++) {\n      var key = selectedKey_1[_i];\n      selectedIndices.push(this._getSelectedIndex(options, key));\n    }\n\n    return selectedIndices;\n  };\n  /** Get all selected options for multi-select mode */\n\n\n  DropdownBase.prototype._getAllSelectedOptions = function (options, selectedIndices) {\n    var selectedOptions = [];\n\n    for (var _i = 0, selectedIndices_1 = selectedIndices; _i < selectedIndices_1.length; _i++) {\n      var index = selectedIndices_1[_i];\n      var option = options[index];\n\n      if (option) {\n        selectedOptions.push(option);\n      }\n    }\n\n    return selectedOptions;\n  };\n\n  DropdownBase.prototype._getAllSelectedIndices = function (options) {\n    return options.map(function (option, index) {\n      return option.selected ? index : -1;\n    }).filter(function (index) {\n      return index !== -1;\n    });\n  };\n\n  DropdownBase.prototype._getSelectedIndex = function (options, selectedKey) {\n    return findIndex(options, function (option) {\n      // tslint:disable-next-line:triple-equals\n      if (selectedKey != null) {\n        return option.key === selectedKey;\n      } else {\n        return !!option.isSelected || !!option.selected;\n      }\n    });\n  };\n  /**\r\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\r\n   */\n\n\n  DropdownBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n  /**\r\n   * We close the menu on key up only if ALL of the following are true:\r\n   * - Most recent key down was alt or meta (command)\r\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\r\n   *   expand/collapse the menu)\r\n   * - We're not on a Mac (or iOS)\r\n   *\r\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\r\n   * closing any open context menus. There is not a similar behavior on Macs.\r\n   */\n\n\n  DropdownBase.prototype._shouldHandleKeyUp = function (ev) {\n    var keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n  };\n\n  DropdownBase.defaultProps = {\n    options: []\n  };\n  DropdownBase = tslib_1.__decorate([withResponsiveMode], DropdownBase);\n  return DropdownBase;\n}(BaseComponent);\n\nexport { DropdownBase };","map":null,"metadata":{},"sourceType":"module"}