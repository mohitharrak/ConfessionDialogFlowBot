{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseComponent, KeyCodes, elementContains, getNativeProps, divProperties, getFirstTabbable, getLastTabbable, getNextElement, focusAsync } from '../../Utilities';\n\nvar FocusTrapZone =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FocusTrapZone, _super);\n\n  function FocusTrapZone() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._root = React.createRef();\n\n    _this._onFocusCapture = function (ev) {\n      if (_this.props.onFocusCapture) {\n        _this.props.onFocusCapture(ev);\n      }\n\n      if (ev.target !== ev.currentTarget) {\n        // every time focus changes within the trap zone, remember the focused element so that\n        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))\n        _this._previouslyFocusedElementInTrapZone = ev.target;\n      }\n    };\n\n    _this._onKeyboardHandler = function (ev) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n      } // If the default has been prevented, do not process keyboard events.\n\n\n      if (ev.isDefaultPrevented()) {\n        return;\n      }\n\n      if (ev.which !== KeyCodes.tab) {\n        return;\n      }\n\n      if (!_this._root.current) {\n        return;\n      }\n\n      var _firstTabbableChild = getFirstTabbable(_this._root.current, _this._root.current.firstChild, true);\n\n      var _lastTabbableChild = getLastTabbable(_this._root.current, _this._root.current.lastChild, true);\n\n      if (ev.shiftKey && _firstTabbableChild === ev.target) {\n        focusAsync(_lastTabbableChild);\n        ev.preventDefault();\n        ev.stopPropagation();\n      } else if (!ev.shiftKey && _lastTabbableChild === ev.target) {\n        focusAsync(_firstTabbableChild);\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    };\n\n    return _this;\n  }\n\n  FocusTrapZone.prototype.componentDidMount = function () {\n    this._bringFocusIntoZone();\n\n    this._updateEventHandlers(this.props);\n  };\n\n  FocusTrapZone.prototype.componentWillReceiveProps = function (nextProps) {\n    var elementToFocusOnDismiss = nextProps.elementToFocusOnDismiss;\n\n    if (elementToFocusOnDismiss && this._previouslyFocusedElementOutsideTrapZone !== elementToFocusOnDismiss) {\n      this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss;\n    }\n\n    this._updateEventHandlers(nextProps);\n  };\n\n  FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {\n    var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrap !== undefined ? prevProps.forceFocusInsideTrap : true;\n    var newForceFocusInsideTrap = this.props.forceFocusInsideTrap !== undefined ? this.props.forceFocusInsideTrap : true;\n\n    if (!prevForceFocusInsideTrap && newForceFocusInsideTrap) {\n      // Transition from forceFocusInsideTrap disabled to enabled. Emulate what happens when a FocusTrapZone gets mounted\n      this._bringFocusIntoZone();\n    } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap) {\n      // Transition from forceFocusInsideTrap enabled to disabled. Emulate what happens when a FocusTrapZone gets unmounted\n      this._returnFocusToInitiator();\n    }\n  };\n\n  FocusTrapZone.prototype.componentWillUnmount = function () {\n    this._events.dispose();\n\n    this._returnFocusToInitiator();\n  };\n\n  FocusTrapZone.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        ariaLabelledBy = _a.ariaLabelledBy;\n    var divProps = getNativeProps(this.props, divProperties);\n    return React.createElement(\"div\", tslib_1.__assign({}, divProps, {\n      className: className,\n      ref: this._root,\n      \"aria-labelledby\": ariaLabelledBy,\n      onKeyDown: this._onKeyboardHandler,\n      onFocusCapture: this._onFocusCapture\n    }), this.props.children);\n  };\n\n  FocusTrapZone.prototype.focus = function () {\n    var _a = this.props,\n        focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement,\n        firstFocusableSelector = _a.firstFocusableSelector;\n\n    if (focusPreviouslyFocusedInnerElement && this._previouslyFocusedElementInTrapZone && elementContains(this._root.current, this._previouslyFocusedElementInTrapZone)) {\n      // focus on the last item that had focus in the zone before we left the zone\n      focusAsync(this._previouslyFocusedElementInTrapZone);\n      return;\n    }\n\n    var focusSelector = typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector && firstFocusableSelector();\n\n    var _firstFocusableChild;\n\n    if (this._root.current) {\n      if (focusSelector) {\n        _firstFocusableChild = this._root.current.querySelector('.' + focusSelector);\n      } else {\n        _firstFocusableChild = getNextElement(this._root.current, this._root.current.firstChild, true, false, false, true);\n      }\n    }\n\n    if (_firstFocusableChild) {\n      focusAsync(_firstFocusableChild);\n    }\n  };\n\n  FocusTrapZone.prototype._bringFocusIntoZone = function () {\n    var _a = this.props,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        _b = _a.disableFirstFocus,\n        disableFirstFocus = _b === void 0 ? false : _b;\n\n    FocusTrapZone._focusStack.push(this);\n\n    this._previouslyFocusedElementOutsideTrapZone = elementToFocusOnDismiss ? elementToFocusOnDismiss : document.activeElement;\n\n    if (!elementContains(this._root.current, this._previouslyFocusedElementOutsideTrapZone) && !disableFirstFocus) {\n      this.focus();\n    }\n  };\n\n  FocusTrapZone.prototype._returnFocusToInitiator = function () {\n    var _this = this;\n\n    var ignoreExternalFocusing = this.props.ignoreExternalFocusing;\n    FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {\n      return _this !== value;\n    });\n    var activeElement = document.activeElement;\n\n    if (!ignoreExternalFocusing && this._previouslyFocusedElementOutsideTrapZone && typeof this._previouslyFocusedElementOutsideTrapZone.focus === 'function' && (elementContains(this._root.current, activeElement) || activeElement === document.body)) {\n      focusAsync(this._previouslyFocusedElementOutsideTrapZone);\n    }\n  };\n\n  FocusTrapZone.prototype._updateEventHandlers = function (newProps) {\n    var _a = newProps.isClickableOutsideFocusTrap,\n        isClickableOutsideFocusTrap = _a === void 0 ? false : _a,\n        _b = newProps.forceFocusInsideTrap,\n        forceFocusInsideTrap = _b === void 0 ? true : _b;\n\n    if (forceFocusInsideTrap && !this._hasFocusHandler) {\n      this._events.on(window, 'focus', this._forceFocusInTrap, true);\n    } else if (!forceFocusInsideTrap && this._hasFocusHandler) {\n      this._events.off(window, 'focus', this._forceFocusInTrap, true);\n    }\n\n    this._hasFocusHandler = forceFocusInsideTrap;\n\n    if (!isClickableOutsideFocusTrap && !this._hasClickHandler) {\n      this._events.on(window, 'click', this._forceClickInTrap, true);\n    } else if (isClickableOutsideFocusTrap && this._hasClickHandler) {\n      this._events.off(window, 'click', this._forceClickInTrap, true);\n    }\n\n    this._hasClickHandler = !isClickableOutsideFocusTrap;\n  };\n\n  FocusTrapZone.prototype._forceFocusInTrap = function (ev) {\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      var focusedElement = ev.relatedTarget || document.activeElement;\n\n      if (!elementContains(this._root.current, focusedElement)) {\n        this.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  FocusTrapZone.prototype._forceClickInTrap = function (ev) {\n    if (FocusTrapZone._focusStack.length && this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {\n      var clickedElement = ev.target;\n\n      if (clickedElement && !elementContains(this._root.current, clickedElement)) {\n        this.focus();\n        ev.preventDefault();\n        ev.stopPropagation();\n      }\n    }\n  };\n\n  FocusTrapZone._focusStack = [];\n  return FocusTrapZone;\n}(BaseComponent);\n\nexport { FocusTrapZone };","map":null,"metadata":{},"sourceType":"module"}