{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { BaseComponent, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\n\nvar SpinButton =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SpinButton, _super);\n\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n\n      _this._input.current.select();\n\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n\n      _this.setState({\n        isFocused: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n          precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\r\n     * Validate function to use if one is not passed in\r\n     */\n\n\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n\n    _this._onIncrement = function (value) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\r\n     * Increment function to use if one is not passed in\r\n     */\n\n\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n          max = _a.max,\n          step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n\n    _this._onDecrement = function (value) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\r\n     * Increment function to use if one is not passed in\r\n     */\n\n\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n          min = _a.min,\n          step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\r\n     * This is used when validating text entry\r\n     * in the input (not when changed via the buttons)\r\n     * @param event - the event that fired\r\n     */\n\n\n    _this._validate = function (event) {\n      if (_this.state.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event);\n\n        if (newValue) {\n          _this._lastValidValue = newValue;\n          _this._valueToValidate = undefined;\n\n          _this.setState({\n            value: newValue\n          });\n        }\n      }\n    };\n    /**\r\n     * The method is needed to ensure we are updating the actual input value.\r\n     * without this our value will never change (and validation will not have the correct number)\r\n     * @param event - the event that was fired\r\n     */\n\n\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n\n      _this.setState({\n        value: value\n      });\n    };\n    /**\r\n     * Update the value with the given stepFunction\r\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\r\n     * when spinning in response to a mouseDown\r\n     * @param stepFunction - function to use to step by\r\n     */\n\n\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction) {\n      var newValue = stepFunction(_this.state.value);\n\n      if (newValue) {\n        _this._lastValidValue = newValue;\n\n        _this.setState({\n          value: newValue\n        });\n      }\n\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction);\n        }, stepDelay);\n      }\n    };\n    /**\r\n     * Stop spinning (clear any currently pending update and set spinning to false)\r\n     */\n\n\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n\n        _this._currentStepFunctionHandle = -1;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\r\n     * Handle keydown on the text field. We need to update\r\n     * the value when up or down arrow are depressed\r\n     * @param event - the keyboardEvent that was fired\r\n     */\n\n\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.props.disabled) {\n        _this._stop();\n\n        return;\n      }\n\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onIncrement);\n\n          break;\n\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onDecrement);\n\n          break;\n\n        case KeyCodes.enter:\n        case KeyCodes.tab:\n          _this._validate(event);\n\n          break;\n\n        case KeyCodes.escape:\n          if (_this.state.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n\n          break;\n\n        default:\n          break;\n      } // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n\n\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\r\n     * Make sure that we have stopped spinning on keyUp\r\n     * if the up or down arrow fired this event\r\n     * @param event stop spinning if we\r\n     */\n\n\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n\n        return;\n      }\n    };\n\n    _this._onIncrementMouseDown = function () {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onIncrement);\n    };\n\n    _this._onDecrementMouseDown = function () {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onDecrement);\n    };\n\n    _this._warnMutuallyExclusive({\n      value: 'defaultValue'\n    });\n\n    var value = props.value || props.defaultValue || String(props.min) || '0';\n    _this._lastValidValue = value; // Ensure that the autocalculated precision is not negative.\n\n    _this._precision = _this._calculatePrecision(_this.props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n  /**\r\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\r\n   */\n\n\n  SpinButton.prototype.componentWillReceiveProps = function (newProps) {\n    this._lastValidValue = this.state.value;\n    var value = newProps.value ? newProps.value : String(newProps.min);\n\n    if (newProps.defaultValue) {\n      value = String(Math.max(newProps.min, Math.min(newProps.max, Number(newProps.defaultValue))));\n    }\n\n    if (newProps.value !== undefined) {\n      this.setState({\n        value: value\n      });\n    }\n\n    this._precision = this._calculatePrecision(newProps);\n  };\n\n  SpinButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        max = _a.max,\n        labelPosition = _a.labelPosition,\n        iconProps = _a.iconProps,\n        incrementButtonIcon = _a.incrementButtonIcon,\n        incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n        decrementButtonIcon = _a.decrementButtonIcon,\n        decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n        title = _a.title,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        customStyles = _a.styles,\n        customUpArrowButtonStyles = _a.upArrowButtonStyles,\n        customDownArrowButtonStyles = _a.downArrowButtonStyles,\n        theme = _a.theme,\n        ariaPositionInSet = _a.ariaPositionInSet,\n        ariaSetSize = _a.ariaSetSize,\n        ariaValueNow = _a.ariaValueNow,\n        ariaValueText = _a.ariaValueText,\n        keytipProps = _a.keytipProps,\n        className = _a.className;\n    var _b = this.state,\n        isFocused = _b.isFocused,\n        value = _b.value,\n        keyboardSpinDirection = _b.keyboardSpinDirection;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, !!disabled, !!isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), !!disabled, !!isFocused, keyboardSpinDirection, labelPosition, className);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, tslib_1.__assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", {\n        className: classNames.spinButtonWrapper,\n        title: title && title,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }, React.createElement(\"input\", {\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": !isNaN(Number(ariaValueNow)) ? ariaValueNow : !isNaN(Number(value)) ? Number(value) : undefined,\n        \"aria-valuetext\": ariaValueText ? ariaValueText : isNaN(Number(value)) ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        readOnly: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, {\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }), React.createElement(IconButton, {\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      })));\n    }), labelPosition === Position.bottom && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label\n    }, label)));\n  };\n\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n\n  Object.defineProperty(SpinButton.prototype, \"value\", {\n    /**\r\n     * Gets the value of the spin button.\r\n     */\n    get: function get() {\n      return this.props.value === undefined ? this.state.value : this.props.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpinButton.prototype._onChange = function () {\n    /**\r\n     * A noop input change handler.\r\n     * https://github.com/facebook/react/issues/7027.\r\n     * Using the native onInput handler fixes the issue but onChange\r\n     * still need to be wired to avoid React console errors\r\n     * TODO: Check if issue is resolved when React 16 is available.\r\n     */\n  };\n\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = tslib_1.__decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(BaseComponent);\n\nexport { SpinButton };","map":null,"metadata":{},"sourceType":"module"}